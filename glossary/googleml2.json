{ "source": "https://developers.google.com/machine-learning/glossary",
"date": "2025-3-16", "terms": {
    "ablation": "A technique for evaluating the importance of a feature or component by temporarily removing it from a model. You then retrain the model without that feature or component, and if the retrained model performs significantly worse, then the removed feature or component was likely important.\n\nFor example, suppose you train a classification model on 10 features and achieve 88% precision on the test set. To check the importance of the first feature, you can retrain the model using only the nine other features. If the retrained model performs significantly worse (for instance, 55% precision), then the removed feature was probably important. Conversely, if the retrained model performs equally well, then that feature was probably not that important.\n\nAblation can also help determine the importance of:\n\n- Larger components, such as an entire subsystem of a larger ML system\n- Processes or techniques, such as a data preprocessing step\n\nIn both cases, you would observe how the system's performance changes (or doesn't change) after you've removed the component.",

"A/B testing": "A statistical way of comparing two (or more) techniquesâ€”the A and the B. Typically, the A is an existing technique, and the B is a new technique. A/B testing not only determines which technique performs better but also whether the difference is statistically significant.\n\nA/B testing usually compares a single metric on two techniques; for example, how does model accuracy compare for two techniques? However, A/B testing can also compare any finite number of metrics.",
    "accelerator chip": "#GoogleCloud\nA category of specialized hardware components designed to perform key computations needed for deep learning algorithms.\n\nAccelerator chips (or just accelerators, for short) can significantly increase the speed and efficiency of training and inference tasks compared to a general-purpose CPU. They are ideal for training neural networks and similar computationally intensive tasks.\n\nExamples of accelerator chips include:\n\n- Google's Tensor Processing Units (TPUs) with dedicated hardware for deep learning.\n- NVIDIA's GPUs which, though initially designed for graphics processing, are designed to enable parallel processing, which can significantly increase processing speed.",
    "accuracy": "#fundamentals#Metric\nThe number of correct classification predictions divided by the total number of predictions. That is:\n\nAccuracy = (Number of correct predictions) / (Total number of predictions)\n\nFor example, a model that made 40 correct predictions and 10 incorrect predictions would have an accuracy of:\n\nAccuracy = 40 / (40 + 10) = 0.8 or 80%\n\nBinary classification provides specific names for the different categories of correct predictions and incorrect predictions. So, the accuracy formula for binary classification is as follows:\n\nAccuracy = (TP + TN) / (TP + TN + FP + FN)\n\nwhere:\n\n- TP is the number of true positives (correct predictions).\n- TN is the number of true negatives (correct predictions).\n- FP is the number of false positives (incorrect predictions).\n- FN is the number of false negatives (incorrect predictions).\n\nCompare and contrast accuracy with precision and recall.",

"action":
"#rlIn reinforcement learning, the mechanism by which the agent transitions between states of the environment. The agent chooses the action by using a policy.",

    "activation function": "#fundamentals\nA function that enables neural networks to learn nonlinear (complex) relationships between features and the label.\n\nPopular activation functions include:\n\n- ReLU\n- Sigmoid\n\nThe plots of activation functions are never single straight lines. For example, the plot of the ReLU activation function consists of two straight lines:\n\nA cartesian plot of two lines. The first line has a constant y value of 0, running along the x-axis from -infinity,0 to 0,-0. The second line starts at 0,0. This line has a slope of +1, so it runs from 0,0 to +infinity,+infinity.\n\nA plot of the sigmoid activation function looks as follows:\n\nA two-dimensional curved plot with x values spanning the domain -infinity to +positive, while y values span the range almost 0 to almost 1. When x is 0, y is 0.5. The slope of the curve is always positive, with the highest slope at 0,0.5 and gradually decreasing slopes as the absolute value of x increases.\n\nSee Neural networks: Activation functions in Machine Learning Crash Course for more information.",



"active learning":
"A training approach in which the algorithm chooses some of the data it learns from. Active learning is particularly valuable when labeled examples are scarce or expensive to obtain. Instead of blindly seeking a diverse range of labeled examples, an active learning algorithm selectively seeks the particular range of examples it needs for learning.",


"AdaGrad":
"A sophisticated gradient descent algorithm that rescales the gradients of each parameter, effectively giving each parameter an independent learning rate. For a full explanation, see Adaptive Subgradient Methods for Online Learning and Stochastic Optimization.",

"agent": "#rl\nIn reinforcement learning, the entity that uses a policy to maximize the expected return gained from transitioning between states of the environment.\n\nMore generally, an agent is software that autonomously plans and executes a series of actions in pursuit of a goal, with the ability to adapt to changes in its environment. For example, an LLM-based agent might use an LLM to generate a plan, rather than applying a reinforcement learning policy.",


    "agglomerative clustering": "See hierarchical clustering.",
    "anomaly detection": "The process of identifying outliers. For example, if the mean for a certain feature is 100 with a standard deviation of 10, then anomaly detection should flag a value of 200 as suspicious.",
    "AR": "Abbreviation for augmented reality.",



 "area under the PR curve": "See PR AUC (Area under the PR Curve).",
    "area under the ROC curve": "See AUC (Area under the ROC curve).",
    "artificial general intelligence": "A non-human mechanism that demonstrates a broad range of problem solving, creativity, and adaptability. For example, a program demonstrating artificial general intelligence could translate text, compose symphonies, and excel at games that have not yet been invented.",


    "artificial intelligence": "A non-human program or model that can solve sophisticated tasks. For example, a program or model that translates text or a program or model that identifies diseases from radiologic images both exhibit artificial intelligence.\n\nFormally, machine learning is a sub-field of artificial intelligence. However, in recent years, some organizations have begun using the terms artificial intelligence and machine learning interchangeably.",
    "attention": "A mechanism used in a neural network that indicates the importance of a particular word or part of a word. Attention compresses the amount of information a model needs to predict the next token/word. A typical attention mechanism might consist of a weighted sum over a set of inputs, where the weight for each input is computed by another part of the neural network.\n\nRefer also to self-attention and multi-head self-attention, which are the building blocks of Transformers.\n\nSee LLMs: What's a large language model? in Machine Learning Crash Course for more information about self-attention.",
    "attribute": "Synonym for feature.\n\nIn machine learning fairness, attributes often refer to characteristics pertaining to individuals.",
    "attribute sampling": "A tactic for training a decision forest in which each decision tree considers only a random subset of possible features when learning the condition. Generally, a different subset of features is sampled for each node. In contrast, when training a decision tree without attribute sampling, all possible features are considered for each node.",


"AUC (Area under the ROC curve)": "A number between 0.0 and 1.0 representing a binary classification model's ability to separate positive classes from negative classes. The closer the AUC is to 1.0, the better the model's ability to separate classes from each other.\n\nFor example, the following illustration shows a classification model that separates positive classes (green ovals) from negative classes (purple rectangles) perfectly. This unrealistically perfect model has an AUC of 1.0:\n\nA number line with 8 positive examples on one side and 9 negative examples on the other side.\n\nConversely, the following illustration shows the results for a classification model that generated random results. This model has an AUC of 0.5:\n\nA number line with 6 positive examples and 6 negative examples. The sequence of examples is positive, negative, positive, negative, positive, negative, positive, negative, positive, negative, positive, negative.\n\nYes, the preceding model has an AUC of 0.5, not 0.0.\n\nMost models are somewhere between the two extremes. For instance, the following model separates positives from negatives somewhat, and therefore has an AUC somewhere between 0.5 and 1.0:\n\nA number line with 6 positive examples and 6 negative examples. The sequence of examples is negative, negative, negative, negative, positive, negative, positive, positive, negative, positive, positive, positive.\n\nAUC ignores any value you set for classification threshold. Instead, AUC considers all possible classification thresholds.\n\nSee Classification: ROC and AUC in Machine Learning Crash Course for more information.",
    "augmented reality": "A technology that superimposes a computer-generated image on a user's view of the real world, thus providing a composite view.",
 "autoencoder": "A system that learns to extract the most important information from the input. Autoencoders are a combination of an encoder and decoder. Autoencoders rely on the following two-step process:\n\nThe encoder maps the input to a (typically) lossy lower-dimensional (intermediate) format.\nThe decoder builds a lossy version of the original input by mapping the lower-dimensional format to the original higher-dimensional input format.\n\nAutoencoders are trained end-to-end by having the decoder attempt to reconstruct the original input from the encoder's intermediate format as closely as possible. Because the intermediate format is smaller (lower-dimensional) than the original format, the autoencoder is forced to learn what information in the input is essential, and the output won't be perfectly identical to the input.\n\nFor example:\n\n- If the input data is a graphic, the non-exact copy would be similar to the original graphic, but somewhat modified. Perhaps the non-exact copy removes noise from the original graphic or fills in some missing pixels.\n- If the input data is text, an autoencoder would generate new text that mimics (but is not identical to) the original text.\n\nSee also variational autoencoders.",
    "automatic evaluation": "Using software to judge the quality of a model's output.\n\nWhen model output is relatively straightforward, a script or program can compare the model's output to a golden response. This type of automatic evaluation is sometimes called programmatic evaluation. Metrics such as ROUGE or BLEU are often useful for programmatic evaluation.\n\nWhen model output is complex or has no one right answer, a separate ML program called an autorater sometimes performs the automatic evaluation.\n\nContrast with human evaluation.",
    "automation bias": "When a human decision maker favors recommendations made by an automated decision-making system over information made without automation, even when the automated decision-making system makes errors.\n\nSee Fairness: Types of bias in Machine Learning Crash Course for more information.",
"AutoML": "Any automated process for building machine learning models. AutoML can automatically do tasks such as the following:\n\n- Search for the most appropriate model.\n- Tune hyperparameters.\n- Prepare data (including performing feature engineering).\n- Deploy the resulting model.\n\nAutoML is useful for data scientists because it can save them time and effort in developing machine learning pipelines and improve prediction accuracy. It is also useful to non-experts, by making complicated machine learning tasks more accessible to them.\n\nSee Automated Machine Learning (AutoML) in Machine Learning Crash Course for more information.",
    "autorater evaluation": "A hybrid mechanism for judging the quality of a generative AI model's output that combines human evaluation with automatic evaluation. An autorater is an ML model trained on data created by human evaluation. Ideally, an autorater learns to mimic a human evaluator.\n\nPrebuilt autoraters are available, but the best autoraters are fine-tuned specifically to the task you are evaluating.\n\nNote: A running autorater is a fully automated process; humans 'only' provide data that helps train an autorater.",
    "auto-regressive model": "A model that infers a prediction based on its own previous predictions. For example, auto-regressive language models predict the next token based on the previously predicted tokens. All Transformer-based large language models are auto-regressive.\n\nIn contrast, GAN-based image models are usually not auto-regressive since they generate an image in a single forward-pass and not iteratively in steps. However, certain image generation models are auto-regressive because they generate an image in steps.",
    "auxiliary loss": "A loss functionâ€”used in conjunction with a neural network model's main loss functionâ€”that helps accelerate training during the early iterations when weights are randomly initialized.\n\nAuxiliary loss functions push effective gradients to the earlier layers. This facilitates convergence during training by combating the vanishing gradient problem."
  },

  "average precision at k": "#language#Metric\nA metric for summarizing a model's performance on a single prompt that generates ranked results, such as a numbered list of book recommendations. Average precision at k is, well, the average of the precision at k values for each relevant result. The formula for average precision at k is therefore:\n\n\nwhere:\n\n is the number of relevant items in the list.\nContrast with recall at k.\n\nNote: Average precision at k evaluates the output for a single prompt. Use mean average precision at k to evaluate the quality of a model's output across many different prompts.\nNote: Some people abbreviate average precision at k to simply average precision.\n Click the icon for an example \n\naxis-aligned condition \n#df\nIn a decision tree, a condition that involves only a single feature. For example, if area is a feature, then the following is an axis-aligned condition:\n\n\narea > 200\nContrast with oblique condition.",



  "backpropagation": "#fundamentals\nThe algorithm that implements gradient descent in neural networks.\n\nTraining a neural network involves many iterations of the following two-pass cycle:\n\nDuring the forward pass, the system processes a batch of examples to yield prediction(s). The system compares each prediction to each label value. The difference between the prediction and the label value is the loss for that example. The system aggregates the losses for all the examples to compute the total loss for the current batch.\nDuring the backward pass (backpropagation), the system reduces loss by adjusting the weights of all the neurons in all the hidden layer(s).\nNeural networks often contain many neurons across many hidden layers. Each of those neurons contribute to the overall loss in different ways. Backpropagation determines whether to increase or decrease the weights applied to particular neurons.\n\nThe learning rate is a multiplier that controls the degree to which each backward pass increases or decreases each weight. A large learning rate will increase or decrease each weight more than a small learning rate.\n\nIn calculus terms, backpropagation implements the chain rule. from calculus. That is, backpropagation calculates the partial derivative of the error with respect to each parameter.\n\nYears ago, ML practitioners had to write code to implement backpropagation. Modern ML APIs like Keras now implement backpropagation for you. Phew!\n\nSee Neural networks in Machine Learning Crash Course for more information.",

   





    "bagging": "A method to train an ensemble where each constituent model trains on a random subset of training examples sampled with replacement. For example, a random forest is a collection of decision trees trained with bagging.\n\nThe term bagging is short for bootstrap aggregating.",
    "bag of words": "A representation of the words in a phrase or passage, irrespective of order. For example, bag of words represents the following three phrases identically:\n\n- the dog jumps\n- jumps the dog\n- dog jumps the\n\nEach word is mapped to an index in a sparse vector, where the vector has an index for every word in the vocabulary. For example, the phrase 'the dog jumps' is mapped into a feature vector with non-zero values at the three indexes corresponding to the words 'the', 'dog', and 'jumps'. The non-zero value can be any of the following:\n\n- A 1 to indicate the presence of a word.\n- A count of the number of times a word appears in the bag.\n- Some other value, such as the logarithm of the count of the number of times a word appears in the bag.",
    "baseline": "A model used as a reference point for comparing how well another model (typically, a more complex one) is performing. For example, a logistic regression model might serve as a good baseline for a deep model.\n\nFor a particular problem, the baseline helps model developers quantify the minimal expected performance that a new model must achieve for the new model to be useful.",
    "batch": "The set of examples used in one training iteration. The batch size determines the number of examples in a batch.",
    "batch inference": "The process of inferring predictions on multiple unlabeled examples divided into smaller subsets ('batches').\n\nBatch inference can take advantage of the parallelization features of accelerator chips. That is, multiple accelerators can simultaneously infer predictions on different batches of unlabeled examples, dramatically increasing the number of inferences per second.",
    "batch normalization": "Normalizing the input or output of the activation functions in a hidden layer. Batch normalization can provide the following benefits:\n\n- Make neural networks more stable by protecting against outlier weights.\n- Enable higher learning rates, which can speed training.\n- Reduce overfitting.",
    "batch size": "The number of examples in a batch. For instance, if the batch size is 100, then the model processes 100 examples per iteration.\n\nThe following are popular batch size strategies:\n\n- Stochastic Gradient Descent (SGD), in which the batch size is 1.\n- Full batch, in which the batch size is the number of examples in the entire training set.\n- Mini-batch, in which the batch size is usually between 10 and 1000.",
    "Bayesian neural network": "A probabilistic neural network that accounts for uncertainty in weights and outputs. A standard neural network regression model typically predicts a scalar value; for example, a standard model predicts a house price of 853,000. In contrast, a Bayesian neural network predicts a distribution of values; for example, a Bayesian model predicts a house price of 853,000 with a standard deviation of 67,200.\n\nA Bayesian neural network relies on Bayes' Theorem to calculate uncertainties in weights and predictions. A Bayesian neural network can be useful when it is important to quantify uncertainty, such as in models related to pharmaceuticals. Bayesian neural networks can also help prevent overfitting.",
    "Bayesian optimization": "A probabilistic regression model technique for optimizing computationally expensive objective functions by instead optimizing a surrogate that quantifies the uncertainty using a Bayesian learning technique.",
    "Bellman equation": "In reinforcement learning, the following identity satisfied by the optimal Q-function:\n\nReinforcement learning algorithms apply this identity to create Q-learning using the following update rule.\n\nBeyond reinforcement learning, the Bellman equation has applications to dynamic programming.",
    "BERT (Bidirectional Encoder Representations from Transformers)": "A model architecture for text representation. A trained BERT model can act as part of a larger model for text classification or other ML tasks.\n\nBERT has the following characteristics:\n\n- Uses the Transformer architecture, and therefore relies on self-attention.\n- Uses the encoder part of the Transformer.\n- Is bidirectional.\n- Uses masking for unsupervised training.\n\nBERT's variants include:\n\n- ALBERT, which is an acronym for A Light BERT.\n- LaBSE.",
    "bias (ethics/fairness)": "1. Stereotyping, prejudice or favoritism towards some things, people, or groups over others. These biases can affect collection and interpretation of data, the design of a system, and how users interact with a system.\n\n2. Systematic error introduced by a sampling or reporting procedure.",
    "bias (math) or bias term": "An intercept or offset from an origin. Bias is a parameter in machine learning models, which is symbolized by either of the following:\n\n- b\n- w0\n\nFor example, bias is the b in the following formula.\n\nBias exists because not all models start from the origin (0,0). For example, suppose an amusement park costs 2 Euros to enter and an additional 0.5 Euro for every hour a customer stays. Therefore, a model mapping the total cost has a bias of 2 because the lowest cost is 2 Euros.\n\nBias is not to be confused with bias in ethics and fairness or prediction bias.",


"bidirectional": "#language\nA term used to describe a system that evaluates the text that both precedes and follows a target section of text. In contrast, a unidirectional system only evaluates the text that precedes a target section of text.\n\nFor example, consider a masked language model that must determine probabilities for the word or words representing the underline in the following question:\n\nWhat is the _____ with you?\n\nA unidirectional language model would have to base its probabilities only on the context provided by the words \"What\", \"is\", and \"the\". In contrast, a bidirectional language model could also gain context from \"with\" and \"you\", which might help the model generate better predictions.",
  "bidirectional language model": "#language\nA language model that determines the probability that a given token is present at a given location in an excerpt of text based on the preceding and following text.",
"bigram": "#seq#language\nAn N-gram in which N=2.",
  "binary classification": "#fundamentals\nA type of classification task that predicts one of two mutually exclusive classes:\n\nthe positive class\nthe negative class\nFor example, the following two machine learning models each perform binary classification:\n\nA model that determines whether email messages are spam (the positive class) or not spam (the negative class).\nA model that evaluates medical symptoms to determine whether a person has a particular disease (the positive class) or doesn't have that disease (the negative class).\nContrast with multi-class classification.\n\nSee also logistic regression and classification threshold.\n\nSee Classification in Machine Learning Crash Course for more information.",  "binary condition": "#df\nIn a decision tree, a condition that has only two possible outcomes, typically yes or no. For example, the following is a binary condition:\n\n\ntemperature >= 100\nContrast with non-binary condition.\n\nSee Types of conditions in the Decision Forests course for more information."
,"binning": "Synonym for bucketing.",   "BLEU (Bilingual Evaluation Understudy)": "#language\nA metric between 0.0 and 1.0 for evaluating machine translations, for example, from Spanish to Japanese.\n\nTo calculate a score, BLEU typically compares an ML model's translation (generated text) to a human expert's translation (reference text). The degree to which N-grams in the generated text and reference text match determines the BLEU score.\n\nThe original paper on this metric is BLEU: a Method for Automatic Evaluation of Machine Translation.\n\nSee also BLEURT.",
  "BLEURT (Bilingual Evaluation Understudy from Transformers)": "#language\nA metric for evaluating machine translations from one language to another, particularly to and from English.\n\nFor translations to and from English, BLEURT aligns more closely to human ratings than BLEU. Unlike BLEU, BLEURT emphasizes semantic (meaning) similarities and can accommodate paraphrasing.\n\nBLEURT relies on a pre-trained large language model (BERT to be exact) that is then fine-tuned on text from human translators.\n\nThe original paper on this metric is BLEURT: Learning Robust Metrics for Text Generation.",


  "boosting": "A machine learning technique that iteratively combines a set of simple and not very accurate classifiers (referred to as \"weak\" classifiers) into a classifier with high accuracy (a \"strong\" classifier) by upweighting the examples that the model is currently misclassifying.\n\nSee Gradient Boosted Decision Trees? in the Decision Forests course for more information.",

  "bounding box": "In an image, the (x, y) coordinates of a rectangle around an area of interest, such as the dog in the image below.\n\nPhotograph of a dog sitting on a sofa. A green bounding box with top-left coordinates of (275, 1271) and bottom-right coordinates of (2954, 2761) circumscribes the dog's body.",
  "broadcasting": "Expanding the shape of an operand in a matrix math operation to dimensions compatible for that operation. For example, linear algebra requires that the two operands in a matrix addition operation must have the same dimensions. Consequently, you can't add a matrix of shape (m, n) to a vector of length n. Broadcasting enables this operation by virtually expanding the vector of length n to a matrix of shape (m, n) by replicating the same values down each column.",
  "bucketing": "Converting a single feature into multiple binary features called buckets or bins, typically based on a value range. The chopped feature is typically a continuous feature.\n\nFor example, instead of representing temperature as a single continuous floating-point feature, you could chop ranges of temperatures into discrete buckets, such as:\n\n- <= 10 degrees Celsius would be the 'cold' bucket.\n- 11 - 24 degrees Celsius would be the 'temperate' bucket.\n- >= 25 degrees Celsius would be the 'warm' bucket.\n\nThe model will treat every value in the same bucket identically. For example, the values 13 and 22 are both in the temperate bucket, so the model treats the two values identically.",

"calibration layer": "A post-prediction adjustment, typically to account for prediction bias. The adjusted predictions and probabilities should match the distribution of an observed set of labels.",
"candidate generation": "The initial set of recommendations chosen by a recommendation system. For example, consider a bookstore that offers 100,000 titles. The candidate generation phase creates a much smaller list of suitable books for a particular user, say 500. But even 500 books is way too many to recommend to a user. Subsequent, more expensive, phases of a recommendation system (such as scoring and re-ranking) reduce those 500 to a much smaller, more useful set of recommendations.",
"candidate sampling": "A training-time optimization that calculates a probability for all the positive labels, using, for example, softmax, but only for a random sample of negative labels. For instance, given an example labeled 'beagle' and 'dog', candidate sampling computes the predicted probabilities and corresponding loss terms for:\n\n- beagle\n- dog\n- a random subset of the remaining negative classes (for example, cat, lollipop, fence).\n\nThe idea is that the negative classes can learn from less frequent negative reinforcement as long as positive classes always get proper positive reinforcement, and this is indeed observed empirically.\n\nCandidate sampling is more computationally efficient than training algorithms that compute predictions for all negative classes, particularly when the number of negative classes is very large.",
"categorical data": "Features having a specific set of possible values. For example, consider a categorical feature named 'traffic-light-state', which can only have one of the following three possible values:\n\n- red\n- yellow\n- green\n\nBy representing 'traffic-light-state' as a categorical feature, a model can learn the differing impacts of red, green, and yellow on driver behavior.\n\nCategorical features are sometimes called discrete features. Contrast with numerical data.",
"causal language model": "Synonym for unidirectional language model. See bidirectional language model to contrast different directional approaches in language modeling.",
"centroid": "The center of a cluster as determined by a k-means or k-median algorithm. For example, if k is 3, then the k-means or k-median algorithm finds 3 centroids.",
"centroid-based clustering": "A category of clustering algorithms that organizes data into nonhierarchical clusters. k-means is the most widely used centroid-based clustering algorithm. Contrast with hierarchical clustering algorithms.",
"chain-of-thought prompting": "A prompt engineering technique that encourages a large language model (LLM) to explain its reasoning, step by step. For example, consider the following prompt, paying particular attention to the second sentence:\n\n'How many g forces would a driver experience in a car that goes from 0 to 60 miles per hour in 7 seconds? In the answer, show all relevant calculations.'\n\nThe LLM's response would likely:\n\n- Show a sequence of physics formulas, plugging in the values 0, 60, and 7 in appropriate places.\n- Explain why it chose those formulas and what the various variables mean.\n\nChain-of-thought prompting forces the LLM to perform all the calculations, which might lead to a more correct answer. In addition, chain-of-thought prompting enables the user to examine the LLM's steps to determine whether or not the answer makes sense.",
"chat": "The contents of a back-and-forth dialogue with an ML system, typically a large language model. The previous interaction in a chat (what you typed and how the large language model responded) becomes the context for subsequent parts of the chat.",
  "checkpoint": "Data that captures the state of a model's parameters either during training or after training is completed. For example, during training, you can:\n- Stop training, perhaps intentionally or as the result of certain errors.\n- Capture the checkpoint.\n- Later, reload the checkpoint, possibly on different hardware.\n- Restart training.",
  "class": "\n#fundamentals\nA category that a label can belong to. For example:\n\nIn a binary classification model that detects spam, the two classes might be spam and not spam.\nIn a multi-class classification model that identifies dog breeds, the classes might be poodle, beagle, pug, and so on.\nA classification model predicts a class. In contrast, a regression model predicts a number rather than a class.\n\nSee Classification in Machine Learning Crash Course for more information.",
    "classification model": "#fundamentals\nA model whose prediction is a class. For example, the following are all classification models:\n\nA model that predicts an input sentence's language (French? Spanish? Italian?).\nA model that predicts tree species (Maple? Oak? Baobab?).\nA model that predicts the positive or negative class for a particular medical condition.\nIn contrast, regression models predict numbers rather than classes.\n\nTwo common types of classification models are:\n\nbinary classification\nmulti-class classification",
    "classification threshold": "#fundamentals\nIn a binary classification, a number between 0 and 1 that converts the raw output of a logistic regression model into a prediction of either the positive class or the negative class. Note that the classification threshold is a value that a human chooses, not a value chosen by model training.\n\nA logistic regression model outputs a raw value between 0 and 1. Then:\n\nIf this raw value is greater than the classification threshold, then the positive class is predicted.\nIf this raw value is less than the classification threshold, then the negative class is predicted.\nFor example, suppose the classification threshold is 0.8. If the raw value is 0.9, then the model predicts the positive class. If the raw value is 0.7, then the model predicts the negative class.\n\nThe choice of classification threshold strongly influences the number of false positives and false negatives.\n\n Click the icon for additional notes.\nSee Thresholds and the confusion matrix in Machine Learning Crash Course for more information.",
    "classifier": "#fundamentals\nA casual term for a classification model.",
    "class-imbalanced dataset": "#fundamentals\nA dataset for a classification problem in which the total number of labels of each class differs significantly. For example, consider a binary classification dataset whose two labels are divided as follows:\n\n1,000,000 negative labels\n10 positive labels\nThe ratio of negative to positive labels is 100,000 to 1, so this is a class-imbalanced dataset.\n\nIn contrast, the following dataset is not class-imbalanced because the ratio of negative labels to positive labels is relatively close to 1:\n\n517 negative labels\n483 positive labels\nMulti-class datasets can also be class-imbalanced. For example, the following multi-class classification dataset is also class-imbalanced because one label has far more examples than the other two:\n\n1,000,000 labels with class \"green\"\n200 labels with class \"purple\"\n350 labels with class \"orange\"\nSee also entropy, majority class, and minority class.",
    "clipping": "#fundamentals\nA technique for handling outliers by doing either or both of the following:\n\nReducing feature values that are greater than a maximum threshold down to that maximum threshold.\nIncreasing feature values that are less than a minimum threshold up to that minimum threshold.\nFor example, suppose that <0.5% of values for a particular feature fall outside the range 40\u201360. In this case, you could do the following:\n\nClip all values over 60 (the maximum threshold) to be exactly 60.\nClip all values under 40 (the minimum threshold) to be exactly 40.\nOutliers can damage models, sometimes causing weights to overflow during training. Some outliers can also dramatically spoil metrics like accuracy. Clipping is a common technique to limit the damage.\n\nGradient clipping forces gradient values within a designated range during training.\n\nSee Numerical data: Normalization in Machine Learning Crash Course for more information.",
    "Cloud TPU": "#TensorFlow#GoogleCloud\nA specialized hardware accelerator designed to speed up machine learning workloads on Google Cloud.",
    "clustering": "#clustering\nGrouping related examples, particularly during unsupervised learning. Once all the examples are grouped, a human can optionally supply meaning to each cluster.\n\nMany clustering algorithms exist. For example, the k-means algorithm clusters examples based on their proximity to a centroid, as in the following diagram:\n\nA two-dimensional graph in which the x-axis is labeled tree width,\n          and the y-axis is labeled tree height. The graph contains two\n          centroids and several dozen data points. The data points are\n          categorized based on their proximity. That is, the data points\n          closest to one centroid are categorized as cluster 1, while those\n          closest to the other centroid are categorized as cluster 2.\n\nA human researcher could then review the clusters and, for example, label cluster 1 as \"dwarf trees\" and cluster 2 as \"full-size trees.\"\n\nAs another example, consider a clustering algorithm based on an example's distance from a center point, illustrated as follows:\n\nDozens of data points are arranged in concentric circles, almost\n          like holes around the center of a dart board. The innermost ring\n          of data points is categorized as cluster 1, the middle ring\n          is categorized as cluster 2, and the outermost ring as\n          cluster 3.\n\nSee the Clustering course for more information.",
    "co-adaptation": "When neurons predict patterns in training data by relying almost exclusively on outputs of specific other neurons instead of relying on the network's behavior as a whole. When the patterns that cause co-adaptation are not present in validation data, then co-adaptation causes overfitting. Dropout regularization reduces co-adaptation because dropout ensures neurons cannot rely solely on specific other neurons.",
    "collaborative filtering": "#recsystems\nMaking predictions about the interests of one user based on the interests of many other users. Collaborative filtering is often used in recommendation systems.\n\nSee Collaborative filtering in the Recommendation Systems course for more information.",
    "concept drift": "A shift in the relationship between features and the label. Over time, concept drift reduces a model's quality.\n\nDuring training, the model learns the relationship between the features and their labels in the training set. If the labels in the training set are good proxies for the real-world, then the model should make good real world predictions. However, due to concept drift, the model's predictions tend to degrade over time.\n\nFor example, consider a binary classification model that predicts whether or not a certain car model is \"fuel efficient.\" That is, the features could be:\n\ncar weight\nengine compression\ntransmission type\nwhile the label is either:\n\nfuel efficient\nnot fuel efficient\nHowever, the concept of \"fuel efficient car\" keeps changing. A car model labeled fuel efficient in 1994 would almost certainly be labeled not fuel efficient in 2024. A model suffering from concept drift tends to make less and less useful predictions over time.\n\nCompare and contrast with nonstationarity.\n\n Click the icon for additional notes.",
    "condition": "#df\nIn a decision tree, any node that evaluates an expression. For example, the following portion of a decision tree contains two conditions:\n\nA decision tree consisting of two conditions: (x > 0) and\n          (y > 0).\n\nA condition is also called a split or a test.\n\nContrast condition with leaf.\n\nSee also:\n\nbinary condition\nnon-binary condition.\naxis-aligned-condition\noblique-condition\nSee Types of conditions in the Decision Forests course for more information.",
    "confabulation": "#language\nSynonym for hallucination.\n\nConfabulation is probably a more technically accurate term than hallucination. However, hallucination became popular first.",
    "configuration": "The process of assigning the initial property values used to train a model, including:\n\nthe model's composing layers\nthe location of the data\nhyperparameters such as:\nlearning rate\niterations\noptimizer\nloss function\nIn machine learning projects, configuration can be done through a special configuration file or using configuration libraries such as the following:\n\nHParam\nGin\nFiddle",
    "confirmation bias": "#fairness\nThe tendency to search for, interpret, favor, and recall information in a way that confirms one's pre-existing beliefs or hypotheses. Machine learning developers may inadvertently collect or label data in ways that influence an outcome supporting their existing beliefs. Confirmation bias is a form of implicit bias.\n\nExperimenter's bias is a form of confirmation bias in which an experimenter continues training models until a pre-existing hypothesis is confirmed.",
    "confusion matrix": "#fundamentals\nAn NxN table that summarizes the number of correct and incorrect predictions that a classification model made. For example, consider the following confusion matrix for a binary classification model:\n\nTumor (predicted)\tNon-Tumor (predicted)\nTumor (ground truth)\t18 (TP)\t1 (FN)\nNon-Tumor (ground truth)\t6 (FP)\t452 (TN)\nThe preceding confusion matrix shows the following:\n\nOf the 19 predictions in which ground truth was Tumor, the model correctly classified 18 and incorrectly classified 1.\nOf the 458 predictions in which ground truth was Non-Tumor, the model correctly classified 452 and incorrectly classified 6.\nThe confusion matrix for a multi-class classification problem can help you identify patterns of mistakes. For example, consider the following confusion matrix for a 3-class multi-class classification model that categorizes three different iris types (Virginica, Versicolor, and Setosa). When the ground truth was Virginica, the confusion matrix shows that the model was far more likely to mistakenly predict Versicolor than Setosa:\n\n \tSetosa (predicted)\tVersicolor (predicted)\tVirginica (predicted)\nSetosa (ground truth)\t88\t12\t0\nVersicolor (ground truth)\t6\t141\t7\nVirginica (ground truth)\t2\t27\t109\nAs yet another example, a confusion matrix could reveal that a model trained to recognize handwritten digits tends to mistakenly predict 9 instead of 4, or mistakenly predict 1 instead of 7.\n\nConfusion matrixes contain sufficient information to calculate a variety of performance metrics, including precision and recall.",
    "constituency parsing": "#language\nDividing a sentence into smaller grammatical structures (\"constituents\"). A later part of the ML system, such as a natural language understanding model, can parse the constituents more easily than the original sentence. For example, consider the following sentence:\n\nMy friend adopted two cats.\n\nA constituency parser can divide this sentence into the following two constituents:\n\nMy friend is a noun phrase.\nadopted two cats is a verb phrase.\nThese constituents can be further subdivided into smaller constituents. For example, the verb phrase\n\nadopted two cats\n\ncould be further subdivided into:\n\nadopted is a verb.\ntwo cats is another noun phrase.",
    "contextualized language embedding": "#language#generativeAI\nAn embedding that comes close to \"understanding\" words and phrases in ways that fluent human speakers can. Contextualized language embeddings can understand complex syntax, semantics, and context.\n\nFor example, consider embeddings of the English word cow. Older embeddings such as word2vec can represent English words such that the distance in the embedding space from cow to bull is similar to the distance from ewe (female sheep) to ram (male sheep) or from female to male. Contextualized language embeddings can go a step further by recognizing that English speakers sometimes casually use the word cow to mean either cow or bull.",
    "context window": "#language#generativeAI\nThe number of tokens a model can process in a given prompt. The larger the context window, the more information the model can use to provide coherent and consistent responses to the prompt.",
    "continuous feature": "#fundamentals\nA floating-point feature with an infinite range of possible values, such as temperature or weight.\n\nContrast with discrete feature.",
    "convenience sampling": "Using a dataset not gathered scientifically in order to run quick experiments. Later on, it's essential to switch to a scientifically gathered dataset.",
    "convergence": "#fundamentals\nA state reached when loss values change very little or not at all with each iteration. For example, the following loss curve suggests convergence at around 700 iterations:\n\nCartesian plot. X-axis is loss. Y-axis is the number of training\n          iterations. Loss is very high during first few iterations, but\n          drops sharply. After about 100 iterations, loss is still\n          descending but far more gradually. After about 700 iterations,\n          loss stays flat.\n\nA model converges when additional training won't improve the model.\n\nIn deep learning, loss values sometimes stay constant or nearly so for many iterations before finally descending. During a long period of constant loss values, you may temporarily get a false sense of convergence.\n\nSee also early stopping.\n\nSee Model convergence and loss curves in Machine Learning Crash Course for more information.",
    "convex function": "A function in which the region above the graph of the function is a convex set. The prototypical convex function is shaped something like the letter U. For example, the following are all convex functions:\n\nU-shaped curves, each with a single minimum point.\n\nIn contrast, the following function is not convex. Notice how the region above the graph is not a convex set:\n\nA W-shaped curve with two different local minimum points.\n\nA strictly convex function has exactly one local minimum point, which is also the global minimum point. The classic U-shaped functions are strictly convex functions. However, some convex functions (for example, straight lines) are not U-shaped.\n\n Click the icon for a deeper look at the math.\nSee Convergence and convex functions in Machine Learning Crash Course for more information.",
    "convex optimization": "The process of using mathematical techniques such as gradient descent to find the minimum of a convex function. A great deal of research in machine learning has focused on formulating various problems as convex optimization problems and in solving those problems more efficiently.\n\nFor complete details, see Boyd and Vandenberghe, Convex Optimization.",
    "convex set": "A subset of Euclidean space such that a line drawn between any two points in the subset remains completely within the subset. For instance, the following two shapes are convex sets:\n\nOne illustration of a rectangle. Another illustration of an oval.\n\nIn contrast, the following two shapes are not convex sets:\n\nOne illustration of a pie-chart with a missing slice.\n          Another illustration of a wildly irregular polygon.",
    "convolution": "#image\nIn mathematics, casually speaking, a mixture of two functions. In machine learning, a convolution mixes the convolutional filter and the input matrix in order to train weights.\n\nThe term \"convolution\" in machine learning is often a shorthand way of referring to either convolutional operation or convolutional layer.\n\nWithout convolutions, a machine learning algorithm would have to learn a separate weight for every cell in a large tensor. For example, a machine learning algorithm training on 2K x 2K images would be forced to find 4M separate weights. Thanks to convolutions, a machine learning algorithm only has to find weights for every cell in the convolutional filter, dramatically reducing the memory needed to train the model. When the convolutional filter is applied, it is simply replicated across cells such that each is multiplied by the filter.\n\nSee Introducing Convolutional Neural Networks in the Image Classification course for more information.",
    "convolutional filter": "#image\nOne of the two actors in a convolutional operation. (The other actor is a slice of an input matrix.) A convolutional filter is a matrix having the same rank as the input matrix, but a smaller shape. For example, given a 28x28 input matrix, the filter could be any 2D matrix smaller than 28x28.\n\nIn photographic manipulation, all the cells in a convolutional filter are typically set to a constant pattern of ones and zeroes. In machine learning, convolutional filters are typically seeded with random numbers and then the network trains the ideal values.\n\nSee Convolution in the Image Classification course for more information.",
    "convolutional layer": "#image\nA layer of a deep neural network in which a convolutional filter passes along an input matrix. For example, consider the following 3x3 convolutional filter:\n\nA 3x3 matrix with the following values: [[0,1,0], [1,0,1], [0,1,0]]\n\nThe following animation shows a convolutional layer consisting of 9 convolutional operations involving the 5x5 input matrix. Notice that each convolutional operation works on a different 3x3 slice of the input matrix. The resulting 3x3 matrix (on the right) consists of the results of the 9 convolutional operations:\n\nAn animation showing two matrixes. The first matrix is the 5x5\n          matrix: [[128,97,53,201,198], [35,22,25,200,195],\n          [37,24,28,197,182], [33,28,92,195,179], [31,40,100,192,177]].\n          The second matrix is the 3x3 matrix:\n          [[181,303,618], [115,338,605], [169,351,560]].\n          The second matrix is calculated by applying the convolutional\n          filter [[0, 1, 0], [1, 0, 1], [0, 1, 0]] across\n          different 3x3 subsets of the 5x5 matrix.\n\nSee Fully Connected Layers in the Image Classification course for more information.",
    "convolutional neural network": "#image\nA neural network in which at least one layer is a convolutional layer. A typical convolutional neural network consists of some combination of the following layers:",
    "convolutional layers": "pooling layers\ndense layers\nConvolutional neural networks have had great success in certain kinds of problems, such as image recognition.",
    "convolutional operation": "#image\nThe following two-step mathematical operation:\n\nElement-wise multiplication of the convolutional filter and a slice of an input matrix. (The slice of the input matrix has the same rank and size as the convolutional filter.)\nSummation of all the values in the resulting product matrix.\nFor example, consider the following 5x5 input matrix:\n\nThe 5x5 matrix: [[128,97,53,201,198], [35,22,25,200,195],\n          [37,24,28,197,182], [33,28,92,195,179], [31,40,100,192,177]].\n\nNow imagine the following 2x2 convolutional filter:\n\nThe 2x2 matrix: [[1, 0], [0, 1]]\n\nEach convolutional operation involves a single 2x2 slice of the input matrix. For example, suppose we use the 2x2 slice at the top-left of the input matrix. So, the convolution operation on this slice looks as follows:\n\nApplying the convolutional filter [[1, 0], [0, 1]] to the top-left\n          2x2 section of the input matrix, which is [[128,97], [35,22]].\n          The convolutional filter leaves the 128 and 22 intact, but zeroes\n          out the 97 and 35. Consequently, the convolution operation yields\n          the value 150 (128+22).\n\nA convolutional layer consists of a series of convolutional operations, each acting on a different slice of the input matrix.",
    "cost": "#Metric\nSynonym for loss.",
    "co-training": "A semi-supervised learning approach particularly useful when all of the following conditions are true:\n\nThe ratio of unlabeled examples to labeled examples in the dataset is high.\nThis is a classification problem (binary or multi-class).\nThe dataset contains two different sets of predictive features that are independent of each other and complementary.\nCo-training essentially amplifies independent signals into a stronger signal. For example, consider a classification model that categorizes individual used cars as either Good or Bad. One set of predictive features might focus on aggregate characteristics such as the year, make, and model of the car; another set of predictive features might focus on the previous owner's driving record and the car's maintenance history.\n\nThe seminal paper on co-training is Combining Labeled and Unlabeled Data with Co-Training by Blum and Mitchell.",
    "counterfactual fairness": "#fairness#Metric\nA fairness metric that checks whether a classification model produces the same result for one individual as it does for another individual who is identical to the first, except with respect to one or more sensitive attributes. Evaluating a classification model for counterfactual fairness is one method for surfacing potential sources of bias in a model.\n\nSee either of the following for more information:\n\nFairness: Counterfactual fairness in Machine Learning Crash Course.\nWhen Worlds Collide: Integrating Different Counterfactual Assumptions in Fairness",
    "coverage bias": "#fairness\nSee selection bias.",
    "crash blossom": "#language\nA sentence or phrase with an ambiguous meaning. Crash blossoms present a significant problem in natural language understanding. For example, the headline Red Tape Holds Up Skyscraper is a crash blossom because an NLU model could interpret the headline literally or figuratively.\n\n Click the icon for additional notes.",
    "critic": "#rl\nSynonym for Deep Q-Network.",
    "cross-entropy": "#Metric\nA generalization of Log Loss to multi-class classification problems. Cross-entropy quantifies the difference between two probability distributions. See also perplexity.",
    "cross-validation": "A mechanism for estimating how well a model would generalize to new data by testing the model against one or more non-overlapping data subsets withheld from the training set.",
    "cumulative distribution function (CDF)": "#Metric\nA function that defines the frequency of samples less than or equal to a target value. For example, consider a normal distribution of continuous values. A CDF tells you that approximately 50% of samples should be less than or equal to the mean and that approximately 84% of samples should be less than or equal to one standard deviation above the mean.\n\n\nD",
    "data analysis": "Obtaining an understanding of data by considering samples, measurement, and visualization. Data analysis can be particularly useful when a dataset is first received, before one builds the first model. It is also crucial in understanding experiments and debugging problems with the system.",
    "data augmentation": "#image\nArtificially boosting the range and number of training examples by transforming existing examples to create additional examples. For example, suppose images are one of your features, but your dataset doesn't contain enough image examples for the model to learn useful associations. Ideally, you'd add enough labeled images to your dataset to enable your model to train properly. If that's not possible, data augmentation can rotate, stretch, and reflect each image to produce many variants of the original picture, possibly yielding enough labeled data to enable excellent training.",
    "DataFrame": "#fundamentals\nA popular pandas data type for representing datasets in memory.\n\nA DataFrame is analogous to a table or a spreadsheet. Each column of a DataFrame has a name (a header), and each row is identified by a unique number.\n\nEach column in a DataFrame is structured like a 2D array, except that each column can be assigned its own data type.\n\nSee also the official pandas.DataFrame reference page.",
    "data parallelism": "A way of scaling training or inference that replicates an entire model onto multiple devices and then passes a subset of the input data to each device. Data parallelism can enable training and inference on very large batch sizes; however, data parallelism requires that the model be small enough to fit on all devices.\n\nData parallelism typically speeds training and inference.\n\nSee also model parallelism.",
    "Dataset API (tf.data)": "#TensorFlow\nA high-level TensorFlow API for reading data and transforming it into a form that a machine learning algorithm requires. A tf.data.Dataset object represents a sequence of elements, in which each element contains one or more Tensors. A tf.data.Iterator object provides access to the elements of a Dataset.",
    "data set or dataset": "#fundamentals\nA collection of raw data, commonly (but not exclusively) organized in one of the following formats:\n\na spreadsheet\na file in CSV (comma-separated values) format",
    "decision boundary": "The separator between classes learned by a model in a binary class or multi-class classification problems. For example, in the following image representing a binary classification problem, the decision boundary is the frontier between the orange class and the blue class:\n\nA well-defined boundary between one class and another.",
    "decision forest": "#df\nA model created from multiple decision trees. A decision forest makes a prediction by aggregating the predictions of its decision trees. Popular types of decision forests include random forests and gradient boosted trees.\n\nSee the Decision Forests section in the Decision Forests course for more information.",
    "decision threshold": "Synonym for classification threshold.",
    "decision tree": "#df\nA supervised learning model composed of a set of conditions and leaves organized hierarchically. For example, the following is a decision tree:\n\nA decision tree consisting of four conditions arranged\n          hierarchically, which lead to five leaves.",
    "decoder": "#language\nIn general, any ML system that converts from a processed, dense, or internal representation to a more raw, sparse, or external representation.\n\nDecoders are often a component of a larger model, where they are frequently paired with an encoder.\n\nIn sequence-to-sequence tasks, a decoder starts with the internal state generated by the encoder to predict the next sequence.\n\nRefer to Transformer for the definition of a decoder within the Transformer architecture.\n\nSee Large language models in Machine Learning Crash Course for more information.",
    "deep model": "#fundamentals\nA neural network containing more than one hidden layer.\n\nA deep model is also called a deep neural network.\n\nContrast with wide model.",
    "deep neural network": "Synonym for deep model.",
    "Deep Q-Network (DQN)": "#rl\nIn Q-learning, a deep neural network that predicts Q-functions.\n\nCritic is a synonym for Deep Q-Network.",
    "demographic parity": "#fairness#Metric\nA fairness metric that is satisfied if the results of a model's classification are not dependent on a given sensitive attribute.\n\nFor example, if both Lilliputians and Brobdingnagians apply to Glubbdubdrib University, demographic parity is achieved if the percentage of Lilliputians admitted is the same as the percentage of Brobdingnagians admitted, irrespective of whether one group is on average more qualified than the other.\n\nContrast with equalized odds and equality of opportunity, which permit classification results in aggregate to depend on sensitive attributes, but don't permit classification results for certain specified ground truth labels to depend on sensitive attributes. See \"Attacking discrimination with smarter machine learning\" for a visualization exploring the tradeoffs when optimizing for demographic parity.\n\nSee Fairness: demographic parity in Machine Learning Crash Course for more information.",
    "denoising": "#language\nA common approach to self-supervised learning in which:\n\nNoise is artificially added to the dataset.\nThe model tries to remove the noise.\nDenoising enables learning from unlabeled examples. The original dataset serves as the target or label and the noisy data as the input.\n\nSome masked language models use denoising as follows:\n\nNoise is artificially added to an unlabeled sentence by masking some of the tokens.\nThe model tries to predict the original tokens.",
    "dense feature": "#fundamentals\nA feature in which most or all values are nonzero, typically a Tensor of floating-point values. For example, the following 10-element Tensor is dense because 9 of its values are nonzero:\n\n8\t3\t7\t5\t2\t4\t0\t4\t9\t6\nContrast with sparse feature.",
    "dense layer": "Synonym for fully connected layer.",
    "depth": "#fundamentals\nThe sum of the following in a neural network:\n\nthe number of hidden layers\nthe number of output layers, which is typically 1\nthe number of any embedding layers\nFor example, a neural network with five hidden layers and one output layer has a depth of 6.\n\nNotice that the input layer doesn't influence depth.",
    "depthwise separable convolutional neural network (sepCNN)": "#image\nA convolutional neural network architecture based on Inception, but where Inception modules are replaced with depthwise separable convolutions. Also known as Xception.\n\nA depthwise separable convolution (also abbreviated as separable convolution) factors a standard 3D convolution into two separate convolution operations that are more computationally efficient: first, a depthwise convolution, with a depth of 1 (n \u2715 n \u2715 1), and then second, a pointwise convolution, with length and width of 1 (1 \u2715 1 \u2715 n).\n\nTo learn more, see Xception: Deep Learning with Depthwise Separable Convolutions.",
    "derived label": "Synonym for proxy label.",
    "device": "#TensorFlow#GoogleCloud\nAn overloaded term with the following two possible definitions:\n\nA category of hardware that can run a TensorFlow session, including CPUs, GPUs, and TPUs.\nWhen training an ML model on accelerator chips (GPUs or TPUs), the part of the system that actually manipulates tensors and embeddings. The device runs on accelerator chips. In contrast, the host typically runs on a CPU.",
    "differential privacy": "In machine learning, an anonymization approach to protect any sensitive data (for example, an individual's personal information) included in a model's training set from being exposed. This approach ensures that the model doesn't learn or remember much about a specific individual. This is accomplished by sampling and adding noise during model training to obscure individual data points, mitigating the risk of exposing sensitive training data.\n\nDifferential privacy is also used outside of machine learning. For example, data scientists sometimes use differential privacy to protect individual privacy when computing product usage statistics for different demographics.",
    "dimension reduction": "Decreasing the number of dimensions used to represent a particular feature in a feature vector, typically by converting to an embedding vector.",
    "dimensions": "Overloaded term having any of the following definitions:\n\nThe number of levels of coordinates in a Tensor. For example:\n\nA scalar has zero dimensions; for example, [\"Hello\"].\nA vector has one dimension; for example, [3, 5, 7, 11].\nA matrix has two dimensions; for example, [[2, 4, 18], [5, 7, 14]]. You can uniquely specify a particular cell in a one-dimensional vector with one coordinate; you need two coordinates to uniquely specify a particular cell in a two-dimensional matrix.\nThe number of entries in a feature vector.\n\nThe number of elements in an embedding layer.",
    "direct prompting": "#language#generativeAI\nSynonym for zero-shot prompting.",
    "discrete feature": "#fundamentals\nA feature with a finite set of possible values. For example, a feature whose values may only be animal, vegetable, or mineral is a discrete (or categorical) feature.\n\nContrast with continuous feature.",
    "discriminative model": "A model that predicts labels from a set of one or more features. More formally, discriminative models define the conditional probability of an output given the features and weights; that is:\n\n\np(output | features, weights)\nFor example, a model that predicts whether an email is spam from features and weights is a discriminative model.\n\nThe vast majority of supervised learning models, including classification and regression models, are discriminative models.\n\nContrast with generative model.",
    "discriminator": "A system that determines whether examples are real or fake.\n\nAlternatively, the subsystem within a generative adversarial network that determines whether the examples created by the generator are real or fake.\n\nSee The discriminator in the GAN course for more information.",
    "disparate impact": "#fairness\nMaking decisions about people that impact different population subgroups disproportionately. This usually refers to situations where an algorithmic decision-making process harms or benefits some subgroups more than others.\n\nFor example, suppose an algorithm that determines a Lilliputian's eligibility for a miniature-home loan is more likely to classify them as \"ineligible\" if their mailing address contains a certain postal code. If Big-Endian Lilliputians are more likely to have mailing addresses with this postal code than Little-Endian Lilliputians, then this algorithm may result in disparate impact.\n\nContrast with disparate treatment, which focuses on disparities that result when subgroup characteristics are explicit inputs to an algorithmic decision-making process.",
    "disparate treatment": "#fairness\nFactoring subjects' sensitive attributes into an algorithmic decision-making process such that different subgroups of people are treated differently.\n\nFor example, consider an algorithm that determines Lilliputians' eligibility for a miniature-home loan based on the data they provide in their loan application. If the algorithm uses a Lilliputian's affiliation as Big-Endian or Little-Endian as an input, it is enacting disparate treatment along that dimension.\n\nContrast with disparate impact, which focuses on disparities in the societal impacts of algorithmic decisions on subgroups, irrespective of whether those subgroups are inputs to the model.\n\nWarning: Because sensitive attributes are almost always correlated with other features the data may have, explicitly removing sensitive attribute information doesn't guarantee that subgroups will be treated equally. For example, removing sensitive demographic attributes from a training dataset that still includes postal code as a feature may address disparate treatment of subgroups, but there still might be disparate impact upon these groups because postal code might serve as a proxy for other demographic information.",
    "distillation": "#generativeAI\nThe process of reducing the size of one model (known as the teacher) into a smaller model (known as the student) that emulates the original model's predictions as faithfully as possible. Distillation is useful because the smaller model has two key benefits over the larger model (the teacher):",
    "Faster inference time": "Reduced memory and energy usage\nHowever, the student's predictions are typically not as good as the teacher's predictions.\n\nDistillation trains the student model to minimize a loss function based on the difference between the outputs of the predictions of the student and teacher models.\n\nCompare and contrast distillation with the following terms:",
    "fine-tuning": "#language#image#generativeAI\nA second, task-specific training pass performed on a pre-trained model to refine its parameters for a specific use case. For example, the full training sequence for some large language models is as follows:\n\nPre-training: Train a large language model on a vast general dataset, such as all the English language Wikipedia pages.\nFine-tuning: Train the pre-trained model to perform a specific task, such as responding to medical queries. Fine-tuning typically involves hundreds or thousands of examples focused on the specific task.\nAs another example, the full training sequence for a large image model is as follows:\n\nPre-training: Train a large image model on a vast general image dataset, such as all the images in Wikimedia commons.\nFine-tuning: Train the pre-trained model to perform a specific task, such as generating images of orcas.\nFine-tuning can entail any combination of the following strategies:\n\nModifying all of the pre-trained model's existing parameters. This is sometimes called full fine-tuning.\nModifying only some of the pre-trained model's existing parameters (typically, the layers closest to the output layer), while keeping other existing parameters unchanged (typically, the layers closest to the input layer). See parameter-efficient tuning.\nAdding more layers, typically on top of the existing layers closest to the output layer.\nFine-tuning is a form of transfer learning. As such, fine-tuning might use a different loss function or a different model type than those used to train the pre-trained model. For example, you could fine-tune a pre-trained large image model to produce a regression model that returns the number of birds in an input image.\n\nCompare and contrast fine-tuning with the following terms:\n\ndistillation\nprompt-based learning\nSee Fine-tuning in Machine Learning Crash Course for more information.",
    "distribution": "The frequency and range of different values for a given feature or label. A distribution captures how likely a particular value is.\n\nThe following image shows histograms of two different distributions:\n\nOn the left, a power law distribution of wealth versus the number of people possessing that wealth.\nOn the right, a normal distribution of height versus the number of people possessing that height.\nTwo histograms. One histogram shows a power law distribution with\n          wealth on the x-axis and number of people having that wealth on the\n          y-axis. Most people have very little wealth, and a few people have\n          a lot of wealth. The other histogram shows a normal distribution\n          with height on the x-axis and number of people having that height\n          on the y-axis. Most people are clustered somewhere near the mean.\n\nUnderstanding each feature and label's distribution can help you determine how to normalize values and detect outliers.\n\nThe phrase out of distribution refers to a value that doesn't appear in the dataset or is very rare. For example, an image of the planet Saturn would be considered out of distribution for a dataset consisting of cat images.",
    "divisive clustering": "#clustering\nSee hierarchical clustering.",
    "downsampling": "#image\nOverloaded term that can mean either of the following:\n\nReducing the amount of information in a feature in order to train a model more efficiently. For example, before training an image recognition model, downsampling high-resolution images to a lower-resolution format.\nTraining on a disproportionately low percentage of over-represented class examples in order to improve model training on under-represented classes. For example, in a class-imbalanced dataset, models tend to learn a lot about the majority class and not enough about the minority class. Downsampling helps balance the amount of training on the majority and minority classes.\nSee Datasets: Imbalanced datasets in Machine Learning Crash Course for more information.",
    "DQN": "#rl\nAbbreviation for Deep Q-Network.",
    "dropout regularization": "A form of regularization useful in training neural networks. Dropout regularization removes a random selection of a fixed number of the units in a network layer for a single gradient step. The more units dropped out, the stronger the regularization. This is analogous to training the network to emulate an exponentially large ensemble of smaller networks. For full details, see Dropout: A Simple Way to Prevent Neural Networks from Overfitting.",
    "dynamic": "#fundamentals\nSomething done frequently or continuously. The terms dynamic and online are synonyms in machine learning. The following are common uses of dynamic and online in machine learning:\n\nA dynamic model (or online model) is a model that is retrained frequently or continuously.\nDynamic training (or online training) is the process of training frequently or continuously.\nDynamic inference (or online inference) is the process of generating predictions on demand.",
    "dynamic model": "#fundamentals\nA model that is frequently (maybe even continuously) retrained. A dynamic model is a \"lifelong learner\" that constantly adapts to evolving data. A dynamic model is also known as an online model.\n\nContrast with static model.\n\n\nE",
    "eager execution": "#TensorFlow\nA TensorFlow programming environment in which operations run immediately. In contrast, operations called in graph execution don't run until they are explicitly evaluated. Eager execution is an imperative interface, much like the code in most programming languages. Eager execution programs are generally far easier to debug than graph execution programs.",
    "early stopping": "#fundamentals\nA method for regularization that involves ending training before training loss finishes decreasing. In early stopping, you intentionally stop training the model when the loss on a validation dataset starts to increase; that is, when generalization performance worsens.\n\n Click the icon for additional notes.",
    "earth mover's distance (EMD)": "#Metric\nA measure of the relative similarity of two distributions. The lower the earth mover's distance, the more similar the distributions.",
    "edit distance": "#language#Metric\nA measurement of how similar two text strings are to each other. In machine learning, edit distance is useful for the following reasons:\n\nEdit distance is easy to compute.\nEdit distance can compare two strings known to be similar to each other.\nEdit distance can determine the degree to which different strings are similar to a given string.\nThere are several definitions of edit distance, each using different string operations. See Levenshtein distance for an example.",
    "Einsum notation": "An efficient notation for describing how two tensors are to be combined. The tensors are combined by multiplying the elements of one tensor by the elements of the other tensor and then summing the products. Einsum notation uses symbols to identify the axes of each tensor, and those same symbols are rearranged to specify the shape of the new resulting tensor.\n\nNumPy provides a common Einsum implementation.",
    "embedding layer": "#language#fundamentals\nA special hidden layer that trains on a high-dimensional categorical feature to gradually learn a lower dimension embedding vector. An embedding layer enables a neural network to train far more efficiently than training just on the high-dimensional categorical feature.\n\nFor example, Earth currently supports about 73,000 tree species. Suppose tree species is a feature in your model, so your model's input layer includes a one-hot vector 73,000 elements long. For example, perhaps baobab would be represented something like this:\n\nAn array of 73,000 elements. The first 6,232 elements hold the value\n     0. The next element holds the value 1. The final 66,767 elements hold\n     the value zero.\n\nA 73,000-element array is very long. If you don't add an embedding layer to the model, training is going to be very time consuming due to multiplying 72,999 zeros. Perhaps you pick the embedding layer to consist of 12 dimensions. Consequently, the embedding layer will gradually learn a new embedding vector for each tree species.\n\nIn certain situations, hashing is a reasonable alternative to an embedding layer.\n\nSee Embeddings in Machine Learning Crash Course for more information.",
    "embedding space": "#language\nThe d-dimensional vector space that features from a higher-dimensional vector space are mapped to. Embedding space is trained to capture structure that is meaningful for the intended application.\n\nThe dot product of two embeddings is a measure of their similarity.",
    "embedding vector": "#language\nBroadly speaking, an array of floating-point numbers taken from any hidden layer that describe the inputs to that hidden layer. Often, an embedding vector is the array of floating-point numbers trained in an embedding layer. For example, suppose an embedding layer must learn an embedding vector for each of the 73,000 tree species on Earth. Perhaps the following array is the embedding vector for a baobab tree:\n\nAn array of 12 elements, each holding a floating-point number\n          between 0.0 and 1.0.\n\nAn embedding vector is not a bunch of random numbers. An embedding layer determines these values through training, similar to the way a neural network learns other weights during training. Each element of the array is a rating along some characteristic of a tree species. Which element represents which tree species' characteristic? That's very hard for humans to determine.\n\nThe mathematically remarkable part of an embedding vector is that similar items have similar sets of floating-point numbers. For example, similar tree species have a more similar set of floating-point numbers than dissimilar tree species. Redwoods and sequoias are related tree species, so they'll have a more similar set of floating-pointing numbers than redwoods and coconut palms. The numbers in the embedding vector will change each time you retrain the model, even if you retrain the model with identical input.",
    "empirical cumulative distribution function (eCDF or EDF)": "#Metric\nA cumulative distribution function based on empirical measurements from a real dataset. The value of the function at any point along the x-axis is the fraction of observations in the dataset that are less than or equal to the specified value.",
    "empirical risk minimization (ERM)": "Choosing the function that minimizes loss on the training set. Contrast with structural risk minimization.",
    "encoder": "#language\nIn general, any ML system that converts from a raw, sparse, or external representation into a more processed, denser, or more internal representation.\n\nEncoders are often a component of a larger model, where they are frequently paired with a decoder. Some Transformers pair encoders with decoders, though other Transformers use only the encoder or only the decoder.\n\nSome systems use the encoder's output as the input to a classification or regression network.\n\nIn sequence-to-sequence tasks, an encoder takes an input sequence and returns an internal state (a vector). Then, the decoder uses that internal state to predict the next sequence.\n\nRefer to Transformer for the definition of an encoder in the Transformer architecture.\n\nSee LLMs: What's a large language model in Machine Learning Crash Course for more information.",
    "ensemble": "A collection of models trained independently whose predictions are averaged or aggregated. In many cases, an ensemble produces better predictions than a single model. For example, a random forest is an ensemble built from multiple decision trees. Note that not all decision forests are ensembles.\n\nSee Random Forest in Machine Learning Crash Course for more information.",
    "entropy": "#df#Metric\nIn information theory, a description of how unpredictable a probability distribution is. Alternatively, entropy is also defined as how much information each example contains. A distribution has the highest possible entropy when all values of a random variable are equally likely.\n\nThe entropy of a set with two possible values \"0\" and \"1\" (for example, the labels in a binary classification problem) has the following formula:\n\n  H = -p log p - q log q = -p log p - (1-p) * log (1-p)\n\nwhere:\n\nH is the entropy.\np is the fraction of \"1\" examples.\nq is the fraction of \"0\" examples. Note that q = (1 - p)\nlog is generally log2. In this case, the entropy unit is a bit.\nFor example, suppose the following:\n\n100 examples contain the value \"1\"\n300 examples contain the value \"0\"\nTherefore, the entropy value is:\n\np = 0.25\nq = 0.75\nH = (-0.25)log2(0.25) - (0.75)log2(0.75) = 0.81 bits per example\nA set that is perfectly balanced (for example, 200 \"0\"s and 200 \"1\"s) would have an entropy of 1.0 bit per example. As a set becomes more imbalanced, its entropy moves towards 0.0.\n\nIn decision trees, entropy helps formulate information gain to help the splitter select the conditions during the growth of a classification decision tree.\n\nCompare entropy with:\n\ngini impurity\ncross-entropy loss function\nEntropy is often called Shannon's entropy.\n\nSee Exact splitter for binary classification with numerical features in the Decision Forests course for more information.",
    "environment": "#rl\nIn reinforcement learning, the world that contains the agent and allows the agent to observe that world's state. For example, the represented world can be a game like chess, or a physical world like a maze. When the agent applies an action to the environment, then the environment transitions between states.",
    "episode": "#rl\nIn reinforcement learning, each of the repeated attempts by the agent to learn an environment.",
    "epoch": "#fundamentals\nA full training pass over the entire training set such that each example has been processed once.\n\nAn epoch represents N/batch size training iterations, where N is the total number of examples.\n\nFor instance, suppose the following:\n\nThe dataset consists of 1,000 examples.\nThe batch size is 50 examples.\nTherefore, a single epoch requires 20 iterations:\n\n\n1 epoch = (N/batch size) = (1,000 / 50) = 20 iterations\nSee Linear regression: Hyperparameters in Machine Learning Crash Course for more information.",
    "epsilon greedy policy": "#rl\nIn reinforcement learning, a policy that either follows a random policy with epsilon probability or a greedy policy otherwise. For example, if epsilon is 0.9, then the policy follows a random policy 90% of the time and a greedy policy 10% of the time.\n\nOver successive episodes, the algorithm reduces epsilon's value in order to shift from following a random policy to following a greedy policy. By shifting the policy, the agent first randomly explores the environment and then greedily exploits the results of random exploration.",
    "equality of opportunity": "#fairness#Metric\nA fairness metric to assess whether a model is predicting the desirable outcome equally well for all values of a sensitive attribute. In other words, if the desirable outcome for a model is the positive class, the goal would be to have the true positive rate be the same for all groups.\n\nEquality of opportunity is related to equalized odds, which requires that both the true positive rates and false positive rates are the same for all groups.\n\nSuppose Glubbdubdrib University admits both Lilliputians and Brobdingnagians to a rigorous mathematics program. Lilliputians' secondary schools offer a robust curriculum of math classes, and the vast majority of students are qualified for the university program. Brobdingnagians' secondary schools don't offer math classes at all, and as a result, far fewer of their students are qualified. Equality of opportunity is satisfied for the preferred label of \"admitted\" with respect to nationality (Lilliputian or Brobdingnagian) if qualified students are equally likely to be admitted irrespective of whether they're a Lilliputian or a Brobdingnagian.\n\nFor example, suppose 100 Lilliputians and 100 Brobdingnagians apply to Glubbdubdrib University, and admissions decisions are made as follows:\n\nTable 1. Lilliputian applicants (90% are qualified)\n\n \tQualified\tUnqualified\nAdmitted\t45\t3\nRejected\t45\t7\nTotal\t90\t10\nPercentage of qualified students admitted: 45/90 = 50%\nPercentage of unqualified students rejected: 7/10 = 70%\nTotal percentage of Lilliputian students admitted: (45+3)/100 = 48%\n \n\nTable 2. Brobdingnagian applicants (10% are qualified):\n\n \tQualified\tUnqualified\nAdmitted\t5\t9\nRejected\t5\t81\nTotal\t10\t90\nPercentage of qualified students admitted: 5/10 = 50%\nPercentage of unqualified students rejected: 81/90 = 90%\nTotal percentage of Brobdingnagian students admitted: (5+9)/100 = 14%\nThe preceding examples satisfy equality of opportunity for acceptance of qualified students because qualified Lilliputians and Brobdingnagians both have a 50% chance of being admitted.\n\nWhile equality of opportunity is satisfied, the following two fairness metrics are not satisfied:\n\ndemographic parity: Lilliputians and Brobdingnagians are admitted to the university at different rates; 48% of Lilliputians students are admitted, but only 14% of Brobdingnagian students are admitted.\nequalized odds: While qualified Lilliputian and Brobdingnagian students both have the same chance of being admitted, the additional constraint that unqualified Lilliputians and Brobdingnagians both have the same chance of being rejected is not satisfied. Unqualified Lilliputians have a 70% rejection rate, whereas unqualified Brobdingnagians have a 90% rejection rate.\nSee Fairness: Equality of opportunity in Machine Learning Crash Course for more information.",
    "equalized odds": "#fairness#Metric\nA fairness metric to assess whether a model is predicting outcomes equally well for all values of a sensitive attribute with respect to both the positive class and negative class\u2014not just one class or the other exclusively. In other words, both the true positive rate and false negative rate should be the same for all groups.\n\nEqualized odds is related to equality of opportunity, which only focuses on error rates for a single class (positive or negative).\n\nFor example, suppose Glubbdubdrib University admits both Lilliputians and Brobdingnagians to a rigorous mathematics program. Lilliputians' secondary schools offer a robust curriculum of math classes, and the vast majority of students are qualified for the university program. Brobdingnagians' secondary schools don't offer math classes at all, and as a result, far fewer of their students are qualified. Equalized odds is satisfied provided that no matter whether an applicant is a Lilliputian or a Brobdingnagian, if they are qualified, they are equally as likely to get admitted to the program, and if they are not qualified, they are equally as likely to get rejected.\n\nSuppose 100 Lilliputians and 100 Brobdingnagians apply to Glubbdubdrib University, and admissions decisions are made as follows:\n\nTable 3. Lilliputian applicants (90% are qualified)\n\n \tQualified\tUnqualified\nAdmitted\t45\t2\nRejected\t45\t8\nTotal\t90\t10\nPercentage of qualified students admitted: 45/90 = 50%\nPercentage of unqualified students rejected: 8/10 = 80%\nTotal percentage of Lilliputian students admitted: (45+2)/100 = 47%\n \n\nTable 4. Brobdingnagian applicants (10% are qualified):\n\n \tQualified\tUnqualified\nAdmitted\t5\t18\nRejected\t5\t72\nTotal\t10\t90\nPercentage of qualified students admitted: 5/10 = 50%\nPercentage of unqualified students rejected: 72/90 = 80%\nTotal percentage of Brobdingnagian students admitted: (5+18)/100 = 23%\nEqualized odds is satisfied because qualified Lilliputian and Brobdingnagian students both have a 50% chance of being admitted, and unqualified Lilliputian and Brobdingnagian have an 80% chance of being rejected.\n\nNote: While equalized odds is satisfied here, demographic parity is not satisfied. Lilliputian and Brobdingnagian students are admitted to Glubbdubdrib University at different rates; 47% of Lilliputian students are admitted, and 23% of Brobdingnagian students are admitted.\nEqualized odds is formally defined in \"Equality of Opportunity in Supervised Learning\" as follows: \"predictor \u0176 satisfies equalized odds with respect to protected attribute A and outcome Y if \u0176 and A are independent, conditional on Y.\"\n\nNote: Contrast equalized odds with the more relaxed equality of opportunity metric.",
    "Estimator": "#TensorFlow\nA deprecated TensorFlow API. Use tf.keras instead of Estimators.",
    "evals": "#language#generativeAI#Metric\nPrimarily used as an abbreviation for LLM evaluations. More broadly, evals is an abbreviation for any form of evaluation.",
    "evaluation": "#language#generativeAI#Metric\nThe process of measuring a model's quality or comparing different models against each other.\n\nTo evaluate a supervised machine learning model, you typically judge it against a validation set and a test set. Evaluating a LLM typically involves broader quality and safety assessments.",
    "example": "#fundamentals\nThe values of one row of features and possibly a label. Examples in supervised learning fall into two general categories:\n\nA labeled example consists of one or more features and a label. Labeled examples are used during training.\nAn unlabeled example consists of one or more features but no label. Unlabeled examples are used during inference.\nFor instance, suppose you are training a model to determine the influence of weather conditions on student test scores. Here are three labeled examples:\n\nFeatures\tLabel\nTemperature\tHumidity\tPressure\tTest score\n15\t47\t998\tGood\n19\t34\t1020\tExcellent\n18\t92\t1012\tPoor\nHere are three unlabeled examples:\n\nTemperature\tHumidity\tPressure\t \n12\t62\t1014\t \n21\t47\t1017\t \n19\t41\t1021\t \nThe row of a dataset is typically the raw source for an example. That is, an example typically consists of a subset of the columns in the dataset. Furthermore, the features in an example can also include synthetic features, such as feature crosses.\n\nSee Supervised Learning in the Introduction to Machine Learning course for more information.",
    "experience replay": "#rl\nIn reinforcement learning, a DQN technique used to reduce temporal correlations in training data. The agent stores state transitions in a replay buffer, and then samples transitions from the replay buffer to create training data.",
    "experimenter's bias": "#fairness\nSee confirmation bias.",
    "exploding gradient problem": "#seq\nThe tendency for gradients in deep neural networks (especially recurrent neural networks) to become surprisingly steep (high). Steep gradients often cause very large updates to the weights of each node in a deep neural network.\n\nModels suffering from the exploding gradient problem become difficult or impossible to train. Gradient clipping can mitigate this problem.\n\nCompare to vanishing gradient problem.\n\n\nF",
    "F1": "#Metric\nA \"roll-up\" binary classification metric that relies on both precision and recall. Here is the formula:\n\n Click the icon to see examples.",
    "factuality": "#generativeAI\nWithin the ML world, a property describing a model whose output is based on reality. Factuality is a concept rather than a metric. For example, suppose you send the following prompt to a large language model:\n\nWhat is the chemical formula for table salt?\n\nA model optimizing factuality would respond:\n\nNaCl\n\nIt is tempting to assume that all models should be based on factuality. However, some prompts, such as the following, should cause a generative AI model to optimize creativity rather than factuality.\n\nTell me a limerick about an astronaut and a caterpillar.\n\nIt is unlikely that the resulting limerick would be based on reality.\n\nContrast with groundedness.",
    "fairness constraint": "#fairnessApplying a constraint to an algorithm to ensure one or more definitions of fairness are satisfied. Examples of fairness constraints include:\nPost-processing your model's output.\nAltering the loss function to incorporate a penalty for violating a fairness metric.\nDirectly adding a mathematical constraint to an optimization problem.",
    "fairness metric": "#fairness#Metric\nA mathematical definition of \"fairness\" that is measurable. Some commonly used fairness metrics include:\n\nequalized odds\npredictive parity\ncounterfactual fairness\ndemographic parity\nMany fairness metrics are mutually exclusive; see incompatibility of fairness metrics.",
    "false negative (FN)": "#fundamentals#Metric\nAn example in which the model mistakenly predicts the negative class. For example, the model predicts that a particular email message is not spam (the negative class), but that email message actually is spam.",
    "false negative rate": "#Metric\nThe proportion of actual positive examples for which the model mistakenly predicted the negative class. The following formula calculates the false negative rate:\n\nSee Thresholds and the confusion matrix in Machine Learning Crash Course for more information.",
    "false positive (FP)": "#fundamentals#Metric\nAn example in which the model mistakenly predicts the positive class. For example, the model predicts that a particular email message is spam (the positive class), but that email message is actually not spam.\n\nSee Thresholds and the confusion matrix in Machine Learning Crash Course for more information.",
    "false positive rate (FPR)": "#fundamentals#Metric\nThe proportion of actual negative examples for which the model mistakenly predicted the positive class. The following formula calculates the false positive rate:\n\nThe false positive rate is the x-axis in an ROC curve.\n\nSee Classification: ROC and AUC in Machine Learning Crash Course for more information.",
    "feature": "#fundamentals\nAn input variable to a machine learning model. An example consists of one or more features. For instance, suppose you are training a model to determine the influence of weather conditions on student test scores. The following table shows three examples, each of which contains three features and one label:\n\nFeatures\tLabel\nTemperature\tHumidity\tPressure\tTest score\n15\t47\t998\t92\n19\t34\t1020\t84\n18\t92\t1012\t87\nContrast with label.\n\nSee Supervised Learning in the Introduction to Machine Learning course for more information.",
    "feature cross": "#fundamentals\nA synthetic feature formed by \"crossing\" categorical or bucketed features.\n\nFor example, consider a \"mood forecasting\" model that represents temperature in one of the following four buckets:\n\nfreezing\nchilly\ntemperate\nwarm\nAnd represents wind speed in one of the following three buckets:\n\nstill\nlight\nwindy\nWithout feature crosses, the linear model trains independently on each of the preceding seven various buckets. So, the model trains on, for example, freezing independently of the training on, for example, windy.\n\nAlternatively, you could create a feature cross of temperature and wind speed. This synthetic feature would have the following 12 possible values:\n\nfreezing-still\nfreezing-light\nfreezing-windy\nchilly-still\nchilly-light\nchilly-windy\ntemperate-still\ntemperate-light\ntemperate-windy\nwarm-still\nwarm-light\nwarm-windy\nThanks to feature crosses, the model can learn mood differences between a freezing-windy day and a freezing-still day.\n\nIf you create a synthetic feature from two features that each have a lot of different buckets, the resulting feature cross will have a huge number of possible combinations. For example, if one feature has 1,000 buckets and the other feature has 2,000 buckets, the resulting feature cross has 2,000,000 buckets.\n\nFormally, a cross is a Cartesian product.\n\nFeature crosses are mostly used with linear models and are rarely used with neural networks.\n\nSee Categorical data: Feature crosses in Machine Learning Crash Course for more information.",
    "feature engineering": "#fundamentals#TensorFlow\nA process that involves the following steps:\n\nDetermining which features might be useful in training a model.\nConverting raw data from the dataset into efficient versions of those features.\nFor example, you might determine that temperature might be a useful feature. Then, you might experiment with bucketing to optimize what the model can learn from different temperature ranges.\n\nFeature engineering is sometimes called feature extraction or featurization.\n\n Click the icon for additional notes about TensorFlow.\nSee Numerical data: How a model ingests data using feature vectors in Machine Learning Crash Course for more information.",
    "feature extraction": "Overloaded term having either of the following definitions:\n\nRetrieving intermediate feature representations calculated by an unsupervised or pretrained model (for example, hidden layer values in a neural network) for use in another model as input.\nSynonym for feature engineering.",
    "feature importances": "#df#Metric\nSynonym for variable importances.",
    "feature set": "#fundamentals\nThe group of features your machine learning model trains on. For example, a simple feature set for a model that predicts housing prices might consist of postal code, property size, and property condition.",
    "feature spec": "#TensorFlow\nDescribes the information required to extract features data from the tf.Example protocol buffer. Because the tf.Example protocol buffer is just a container for data, you must specify the following:\n\nThe data to extract (that is, the keys for the features)\nThe data type (for example, float or int)\nThe length (fixed or variable)",
    "feature vector": "#fundamentals\nThe array of feature values comprising an example. The feature vector is input during training and during inference. For example, the feature vector for a model with two discrete features might be:\n\n[0.92, 0.56]\nFour layers: an input layer, two hidden layers, and one output layer.\n          The input layer contains two nodes, one containing the value\n          0.92 and the other containing the value 0.56.\n\nEach example supplies different values for the feature vector, so the feature vector for the next example could be something like:\n\n[0.73, 0.49]\nFeature engineering determines how to represent features in the feature vector. For example, a binary categorical feature with five possible values might be represented with one-hot encoding. In this case, the portion of the feature vector for a particular example would consist of four zeroes and a single 1.0 in the third position, as follows:\n\n[0.0, 0.0, 1.0, 0.0, 0.0]\nAs another example, suppose your model consists of three features:\n\na binary categorical feature with five possible values represented with one-hot encoding; for example: [0.0, 1.0, 0.0, 0.0, 0.0]\nanother binary categorical feature with three possible values represented with one-hot encoding; for example: [0.0, 0.0, 1.0]\na floating-point feature; for example: 8.3.\nIn this case, the feature vector for each example would be represented by nine values. Given the example values in the preceding list, the feature vector would be:\n\n0.0\n1.0\n0.0\n0.0\n0.0\n0.0\n0.0\n1.0\n8.3\nSee Numerical data: How a model ingests data using feature vectors in Machine Learning Crash Course for more information.",
    "featurization": "The process of extracting features from an input source, such as a document or video, and mapping those features into a feature vector.\n\nSome ML experts use featurization as a synonym for feature engineering or feature extraction.",
    "federated learning": "A distributed machine learning approach that trains machine learning models using decentralized examples residing on devices such as smartphones. In federated learning, a subset of devices downloads the current model from a central coordinating server. The devices use the examples stored on the devices to make improvements to the model. The devices then upload the model improvements (but not the training examples) to the coordinating server, where they are aggregated with other updates to yield an improved global model. After the aggregation, the model updates computed by devices are no longer needed, and can be discarded.\n\nSince the training examples are never uploaded, federated learning follows the privacy principles of focused data collection and data minimization.\n\nSee the Federated Learning comic (yes, a comic) for more details.",
    "feedback loop": "#fundamentals\nIn machine learning, a situation in which a model's predictions influence the training data for the same model or another model. For example, a model that recommends movies will influence the movies that people see, which will then influence subsequent movie recommendation models.\n\nSee Production ML systems: Questions to ask in Machine Learning Crash Course for more information.",
    "feedforward neural network (FFN)": "A neural network without cyclic or recursive connections. For example, traditional deep neural networks are feedforward neural networks. Contrast with recurrent neural networks, which are cyclic.",
    "few-shot learning": "A machine learning approach, often used for object classification, designed to train effective classification models from only a small number of training examples.\n\nSee also one-shot learning and zero-shot learning.",
    "few-shot prompting": "#language#generativeAI\nA prompt that contains more than one (a \"few\") example demonstrating how the large language model should respond. For example, the following lengthy prompt contains two examples showing a large language model how to answer a query.\n\nParts of one prompt\tNotes\nWhat is the official currency of the specified country?\tThe question you want the LLM to answer.\nFrance: EUR\tOne example.\nUnited Kingdom: GBP\tAnother example.\nIndia:\tThe actual query.\nFew-shot prompting generally produces more desirable results than zero-shot prompting and one-shot prompting. However, few-shot prompting requires a lengthier prompt.\n\nFew-shot prompting is a form of few-shot learning applied to prompt-based learning.\n\nSee Prompt engineering in Machine Learning Crash Course for more information.",
    "Fiddle": "#language\nA Python-first configuration library that sets the values of functions and classes without invasive code or infrastructure. In the case of Pax\u2014and other ML codebases\u2014these functions and classes represent models and training hyperparameters.\n\nFiddle assumes that machine learning codebases are typically divided into:\n\nLibrary code, which defines the layers and optimizers.\nDataset \"glue\" code, which calls the libraries and wires everything together.\nFiddle captures the call structure of the glue code in an unevaluated and mutable form.",
    "Flax": "#language\nA high-performance open-source library for deep learning built on top of JAX. Flax provides functions for training neural networks, as well as methods for evaluating their performance.",
    "Flaxformer": "#language\nAn open-source Transformer library, built on Flax, designed primarily for natural language processing and multimodal research.",
    "forget gate": "#seq\nThe portion of a Long Short-Term Memory cell that regulates the flow of information through the cell. Forget gates maintain context by deciding which information to discard from the cell state.",
    "fraction of successes": "#generativeAI#Metric\nA metric for evaluating an ML model's generated text. The fraction of successes is the number of \"successful\" generated text outputs divided by the total number of generated text outputs. For example, if a large language model generated 10 blocks of code, five of which were successful, then the fraction of successes would be 50%.\n\nAlthough fraction of successes is broadly useful throughout statistics, within ML, this metric is primarily useful for measuring verifiable tasks like code generation or math problems.",
    "full softmax": "Synonym for softmax.\n\nContrast with candidate sampling.\n\nSee Neural networks: Multi-class classification in Machine Learning Crash Course for more information.",
    "fully connected layer": "A hidden layer in which each node is connected to every node in the subsequent hidden layer.\n\nA fully connected layer is also known as a dense layer.",
    "function transformation": "A function that takes a function as input and returns a transformed function as output. JAX uses function transformations.\n\n\nG",
    "GAN": "Abbreviation for generative adversarial network.",
    "Gemini": "#language#image#generativeAI\nThe ecosystem comprising Google's most advanced AI. Elements of this ecosystem include:\n\nVarious Gemini models.\nThe interactive conversational interface to a Gemini model. Users type prompts and Gemini responds to those prompts.\nVarious Gemini APIs.\nVarious business products based on Gemini models; for example, Gemini for Google Cloud.",
    "Gemini models": "#language#image#generativeAI\nGoogle's state-of-the-art Transformer-based multimodal models. Gemini models are specifically designed to integrate with agents.\n\nUsers can interact with Gemini models in a variety of ways, including through an interactive dialog interface and through SDKs.",
    "generalization": "#fundamentals\nA model's ability to make correct predictions on new, previously unseen data. A model that can generalize is the opposite of a model that is overfitting.\n\n Click the icon for additional notes.\nSee Generalization in Machine Learning Crash Course for more information.",
    "generalization curve": "#fundamentals\nA plot of both training loss and validation loss as a function of the number of iterations.\n\nA generalization curve can help you detect possible overfitting. For example, the following generalization curve suggests overfitting because validation loss ultimately becomes significantly higher than training loss.\n\nA Cartesian graph in which the y-axis is labeled loss and the x-axis\n          is labeled iterations. Two plots appear. One plots shows the\n          training loss and the other shows the validation loss.\n          The two plots start off similarly, but the training loss eventually\n          dips far lower than the validation loss.\n\nSee Generalization in Machine Learning Crash Course for more information.",
    "generalized linear model": "A generalization of least squares regression models, which are based on Gaussian noise, to other types of models based on other types of noise, such as Poisson noise or categorical noise. Examples of generalized linear models include:\n\nlogistic regression\nmulti-class regression\nleast squares regression\nThe parameters of a generalized linear model can be found through convex optimization.\n\nGeneralized linear models exhibit the following properties:\n\nThe average prediction of the optimal least squares regression model is equal to the average label on the training data.\nThe average probability predicted by the optimal logistic regression model is equal to the average label on the training data.\nThe power of a generalized linear model is limited by its features. Unlike a deep model, a generalized linear model cannot \"learn new features.\"",
    "generated text": "#language#generativeAI\nIn general, the text that an ML model outputs. When evaluating large language models, some metrics compare generated text against reference text. For example, suppose you are trying to determine how effectively an ML model translates from French to Dutch. In this case:\n\nThe generated text is the Dutch translation that the ML model outputs.\nThe reference text is the Dutch translation that a human translator (or software) creates.\nNote that some evaluation strategies don't involve reference text.",
    "generative adversarial network (GAN)": "A system to create new data in which a generator creates data and a discriminator determines whether that created data is valid or invalid.\n\nSee the Generative Adversarial Networks course for more information.",
    "generative AI": "#language#image#generativeAI\nAn emerging transformative field with no formal definition. That said, most experts agree that generative AI models can create (\"generate\") content that is all of the following:\n\ncomplex\ncoherent\noriginal\nFor example, a generative AI model can create sophisticated essays or images.\n\nSome earlier technologies, including LSTMs and RNNs, can also generate original and coherent content. Some experts view these earlier technologies as generative AI, while others feel that true generative AI requires more complex output than those earlier technologies can produce.\n\nContrast with predictive ML.",
    "generative model": "Practically speaking, a model that does either of the following:\n\nCreates (generates) new examples from the training dataset. For example, a generative model could create poetry after training on a dataset of poems. The generator part of a generative adversarial network falls into this category.\nDetermines the probability that a new example comes from the training set, or was created from the same mechanism that created the training set. For example, after training on a dataset consisting of English sentences, a generative model could determine the probability that new input is a valid English sentence.\nA generative model can theoretically discern the distribution of examples or particular features in a dataset. That is:\n\np(examples)\nUnsupervised learning models are generative.\n\nContrast with discriminative models.",
    "generator": "The subsystem within a generative adversarial network that creates new examples.\n\nContrast with discriminative model.",
    "gini impurity": "#df#Metric\nA metric similar to entropy. Splitters use values derived from either gini impurity or entropy to compose conditions for classification decision trees. Information gain is derived from entropy. There is no universally accepted equivalent term for the metric derived from gini impurity; however, this unnamed metric is just as important as information gain.\n\nGini impurity is also called gini index, or simply gini.\n\n Click the icon for mathematical details about gini impurity.",
    "golden dataset": "A set of manually curated data that captures ground truth. Teams can use one or more golden datasets to evaluate a model's quality.\n\nSome golden datasets capture different subdomains of ground truth. For example, a golden dataset for image classification might capture lighting conditions and image resolution.",
    "golden response": "#language#generativeAI\nAn answer known to be good. For example, given the following prompt:\n\n2 + 2\n\nThe golden response is hopefully:\n\n4\n\nNote: Some organizations define additional terms such as silver response and platinum response for responses of lower or higher quality, respectively, than the golden response. For example, an organization might use platinum response to indicate a golden response generated by an expert and then further vetted by other experts.\n Click here for notes about golden response and reference text.",
    "GPT (Generative Pre-trained Transformer)": "#language\nA family of Transformer-based large language models developed by OpenAI.\n\nGPT variants can apply to multiple modalities, including:\n\nimage generation (for example, ImageGPT)\ntext-to-image generation (for example, DALL-E).",
    "gradient": "The vector of partial derivatives with respect to all of the independent variables. In machine learning, the gradient is the vector of partial derivatives of the model function. The gradient points in the direction of steepest ascent.",
    "gradient accumulation": "A backpropagation technique that updates the parameters only once per epoch rather than once per iteration. After processing each mini-batch, gradient accumulation simply updates a running total of gradients. Then, after processing the last mini-batch in the epoch, the system finally updates the parameters based on the total of all gradient changes.\n\nGradient accumulation is useful when the batch size is very large compared to the amount of available memory for training. When memory is an issue, the natural tendency is to reduce batch size. However, reducing the batch size in normal backpropagation increases the number of parameter updates. Gradient accumulation enables the model to avoid memory issues but still train efficiently.",
    "gradient boosted (decision) trees (GBT)": "#df\nA type of decision forest in which:\n\nTraining relies on gradient boosting.\nThe weak model is a decision tree.\nSee Gradient Boosted Decision Trees in the Decision Forests course for more information.",
    "gradient boosting": "#df\nA training algorithm where weak models are trained to iteratively improve the quality (reduce the loss) of a strong model. For example, a weak model could be a linear or small decision tree model. The strong model becomes the sum of all the previously trained weak models.\n\nIn the simplest form of gradient boosting, at each iteration, a weak model is trained to predict the loss gradient of the strong model. Then, the strong model's output is updated by subtracting the predicted gradient, similar to gradient descent.\n\nwhere:\n\n is the starting strong model.\n is the next strong model.\n is the current strong model.\n is a value between 0.0 and 1.0 called shrinkage, which is analogous to the learning rate in gradient descent.\n is the weak model trained to predict the loss gradient of \n.\nModern variations of gradient boosting also include the second derivative (Hessian) of the loss in their computation.\n\nDecision trees are commonly used as weak models in gradient boosting. See gradient boosted (decision) trees.",
    "gradient clipping": "#seq\nA commonly used mechanism to mitigate the exploding gradient problem by artificially limiting (clipping) the maximum value of gradients when using gradient descent to train a model.",
    "gradient descent": "#fundamentals\nA mathematical technique to minimize loss. Gradient descent iteratively adjusts weights and biases, gradually finding the best combination to minimize loss.\n\nGradient descent is older\u2014much, much older\u2014than machine learning.\n\nSee the Linear regression: Gradient descent in Machine Learning Crash Course for more information.",
    "graph": "#TensorFlow\nIn TensorFlow, a computation specification. Nodes in the graph represent operations. Edges are directed and represent passing the result of an operation (a Tensor) as an operand to another operation. Use TensorBoard to visualize a graph.",
    "graph execution": "#TensorFlow\nA TensorFlow programming environment in which the program first constructs a graph and then executes all or part of that graph. Graph execution is the default execution mode in TensorFlow 1.x.\n\nContrast with eager execution.",
    "greedy policy": "#rl\nIn reinforcement learning, a policy that always chooses the action with the highest expected return.",
    "groundedness": "A property of a model whose output is based on (is \"grounded on\") specific source material. For example, suppose you provide an entire physics textbook as input (\"context\") to a large language model. Then, you prompt that large language model with a physics question. If the model's response reflects information in that textbook, then that model is grounded on that textbook.\nNote that a grounded model is not always a factual model. For example, the input physics textbook could contain mistakes.",
    "ground truth": "#fundamentals\nReality.\n\nThe thing that actually happened.\n\nFor example, consider a binary classification model that predicts whether a student in their first year of university will graduate within six years. Ground truth for this model is whether or not that student actually graduated within six years.\n\n Click the icon for additional notes.",
    "group attribution bias": "#fairness\nAssuming that what is true for an individual is also true for everyone in that group. The effects of group attribution bias can be exacerbated if a convenience sampling is used for data collection. In a non-representative sample, attributions may be made that don't reflect reality.\n\nSee also out-group homogeneity bias and in-group bias. Also, see Fairness: Types of bias in Machine Learning Crash Course for more information.\n\n\nH",
    "hallucination": "#language\nThe production of plausible-seeming but factually incorrect output by a generative AI model that purports to be making an assertion about the real world. For example, a generative AI model that claims that Barack Obama died in 1865 is hallucinating.",
    "hashing": "In machine learning, a mechanism for bucketing categorical data, particularly when the number of categories is large, but the number of categories actually appearing in the dataset is comparatively small.\n\nFor example, Earth is home to about 73,000 tree species. You could represent each of the 73,000 tree species in 73,000 separate categorical buckets. Alternatively, if only 200 of those tree species actually appear in a dataset, you could use hashing to divide tree species into perhaps 500 buckets.\n\nA single bucket could contain multiple tree species. For example, hashing could place baobab and red maple\u2014two genetically dissimilar species\u2014into the same bucket. Regardless, hashing is still a good way to map large categorical sets into the selected number of buckets. Hashing turns a categorical feature having a large number of possible values into a much smaller number of values by grouping values in a deterministic way.\n\nSee Categorical data: Vocabulary and one-hot encoding in Machine Learning Crash Course for more information.",
    "heuristic": "A simple and quickly implemented solution to a problem. For example, \"With a heuristic, we achieved 86% accuracy. When we switched to a deep neural network, accuracy went up to 98%.\"",
    "hidden layer": "#fundamentals\nA layer in a neural network between the input layer (the features) and the output layer (the prediction). Each hidden layer consists of one or more neurons. For example, the following neural network contains two hidden layers, the first with three neurons and the second with two neurons:\n\nFour layers. The first layer is an input layer containing two\n          features. The second layer is a hidden layer containing three\n          neurons. The third layer is a hidden layer containing two\n          neurons. The fourth layer is an output layer. Each feature\n          contains three edges, each of which points to a different neuron\n          in the second layer. Each of the neurons in the second layer\n          contains two edges, each of which points to a different neuron\n          in the third layer. Each of the neurons in the third layer contain\n          one edge, each pointing to the output layer.\n\nA deep neural network contains more than one hidden layer. For example, the preceding illustration is a deep neural network because the model contains two hidden layers.\n\nSee Neural networks: Nodes and hidden layers in Machine Learning Crash Course for more information.",
    "hierarchical clustering": "#clustering\nA category of clustering algorithms that create a tree of clusters. Hierarchical clustering is well-suited to hierarchical data, such as botanical taxonomies. There are two types of hierarchical clustering algorithms:\n\nAgglomerative clustering first assigns every example to its own cluster, and iteratively merges the closest clusters to create a hierarchical tree.\nDivisive clustering first groups all examples into one cluster and then iteratively divides the cluster into a hierarchical tree.\nContrast with centroid-based clustering.\n\nSee Clustering algorithms in the Clustering course for more information.",
    "hill climbing": "An algorithm for iteratively improving (\"walking uphill\") an ML model until the model stops improving (\"reaches the top of a hill\"). The general form of the algorithm is as follows:\n\nBuild a starting model.\nCreate new candidate models by making small adjustments to the way you train or fine-tune. This might entail working with a slightly different training set or different hyperparameters.\nEvaluate the new candidate models and take one of the following actions:\nIf a candidate model outperforms the starting model, then that candidate model becomes the new starting model. In this case, repeat Steps 1, 2, and 3.\nIf no model outperforms the starting model, then you've reached the top of the hill and should stop iterating.\nNote: Think of the top of the hill as a local maximum that isn't necessarily a global maximum. That is, hill climbing can help you find the best model within your current constraints. However, you might be able to build an even better model by starting over with a new approach.\nSee Deep Learning Tuning Playbook for guidance on hyperparameter tuning. See the Data modules of Machine Learning Crash Course for guidance on feature engineering.",
    "hinge loss": "#Metric\nA family of loss functions for classification designed to find the decision boundary as distant as possible from each training example, thus maximizing the margin between examples and the boundary. KSVMs use hinge loss (or a related function, such as squared hinge loss). For binary classification, the hinge loss function is defined as follows:\n\nwhere y is the true label, either -1 or +1, and y' is the raw output of the classification model:\n\nConsequently, a plot of hinge loss versus (y * y') looks as follows:\n\nA Cartesian plot consisting of two joined line segments. The first\n          line segment starts at (-3, 4) and ends at (1, 0). The second line\n          segment begins at (1, 0) and continues indefinitely with a slope\n          of 0.",
    "historical bias": "#fairness\nA type of bias that already exists in the world and has made its way into a dataset. These biases have a tendency to reflect existing cultural stereotypes, demographic inequalities, and prejudices against certain social groups.\n\nFor example, consider a classification model that predicts whether or not a loan applicant will default on their loan, which was trained on historical loan-default data from the 1980s from local banks in two different communities. If past applicants from Community A were six times more likely to default on their loans than applicants from Community B, the model might learn a historical bias resulting in the model being less likely to approve loans in Community A, even if the historical conditions that resulted in that community's higher default rates were no longer relevant.\n\nSee Fairness: Types of bias in Machine Learning Crash Course for more information.",
    "holdout data": "Examples intentionally not used (\"held out\") during training. The validation dataset and test dataset are examples of holdout data. Holdout data helps evaluate your model's ability to generalize to data other than the data it was trained on. The loss on the holdout set provides a better estimate of the loss on an unseen dataset than does the loss on the training set.",
    "host": "#TensorFlow#GoogleCloud\nWhen training an ML model on accelerator chips (GPUs or TPUs), the part of the system that controls both of the following:\n\nThe overall flow of the code.\nThe extraction and transformation of the input pipeline.\nThe host typically runs on a CPU, not on an accelerator chip; the device manipulates tensors on the accelerator chips.",
    "human evaluation": "#language#generativeAI\nA process in which people judge the quality of an ML model's output; for example, having bilingual people judge the quality of an ML translation model. Human evaluation is particularly useful for judging models that have no one right answer.\n\nContrast with automatic evaluation and autorater evaluation.",
    "human in the loop (HITL)": "#generativeAI\nA loosely-defined idiom that could mean either of the following:\n\nA policy of viewing Generative AI output critically or skeptically. For example, the humans who write this ML Glossary are amazed by what large language models can do but are mindful of the mistakes large language models make.\nA strategy or system for ensuring that people help shape, evaluate, and refine a model's behavior. Keeping a human in the loop enables an AI to benefit from both machine intelligence and human intelligence. For example, a system in which an AI generates code which software engineers then review is a human-in-the-loop system.",
    "hyperparameter": "#fundamentals\nThe variables that you or a hyperparameter tuning service adjust during successive runs of training a model. For example, learning rate is a hyperparameter. You could set the learning rate to 0.01 before one training session. If you determine that 0.01 is too high, you could perhaps set the learning rate to 0.003 for the next training session.\n\nIn contrast, parameters are the various weights and bias that the model learns during training.\n\nSee Linear regression: Hyperparameters in Machine Learning Crash Course for more information.",
    "hyperplane": "A boundary that separates a space into two subspaces. For example, a line is a hyperplane in two dimensions and a plane is a hyperplane in three dimensions. More typically in machine learning, a hyperplane is the boundary separating a high-dimensional space. Kernel Support Vector Machines use hyperplanes to separate positive classes from negative classes, often in a very high-dimensional space.\n\n\nI",
    "i.i.d.": "Abbreviation for independently and identically distributed.",
    "image recognition": "#image\nA process that classifies object(s), pattern(s), or concept(s) in an image. Image recognition is also known as image classification.\n\nFor more information, see ML Practicum: Image Classification.\n\nSee the ML Practicum: Image Classification course for more information.",
    "imbalanced dataset": "Synonym for class-imbalanced dataset.",
    "implicit bias": "#fairness\nAutomatically making an association or assumption based on one's mind models and memories. Implicit bias can affect the following:\n\nHow data is collected and classified.\nHow machine learning systems are designed and developed.\nFor example, when building a classification model to identify wedding photos, an engineer may use the presence of a white dress in a photo as a feature. However, white dresses have been customary only during certain eras and in certain cultures.\n\nSee also confirmation bias.",
    "imputation": "Short form of value imputation.",
    "incompatibility of fairness metrics": "#fairness#Metric\nThe idea that some notions of fairness are mutually incompatible and cannot be satisfied simultaneously. As a result, there is no single universal metric for quantifying fairness that can be applied to all ML problems.\n\nWhile this may seem discouraging, incompatibility of fairness metrics doesn't imply that fairness efforts are fruitless. Instead, it suggests that fairness must be defined contextually for a given ML problem, with the goal of preventing harms specific to its use cases.\n\nSee \"On the (im)possibility of fairness\" for a more detailed discussion of the incompatibility of fairness metrics.",
    "in-context learning": "#language#generativeAI\nSynonym for few-shot prompting.",
    "independently and identically distributed (i.i.d)": "#fundamentals\nData drawn from a distribution that doesn't change, and where each value drawn doesn't depend on values that have been drawn previously. An i.i.d. is the ideal gas of machine learning\u2014a useful mathematical construct but almost never exactly found in the real world. For example, the distribution of visitors to a web page may be i.i.d. over a brief window of time; that is, the distribution doesn't change during that brief window and one person's visit is generally independent of another's visit. However, if you expand that window of time, seasonal differences in the web page's visitors may appear.\n\nSee also nonstationarity.",
    "individual fairness": "#fairness#Metric\nA fairness metric that checks whether similar individuals are classified similarly. For example, Brobdingnagian Academy might want to satisfy individual fairness by ensuring that two students with identical grades and standardized test scores are equally likely to gain admission.\n\nNote that individual fairness relies entirely on how you define \"similarity\" (in this case, grades and test scores), and you can run the risk of introducing new fairness problems if your similarity metric misses important information (such as the rigor of a student's curriculum).\n\nSee \"Fairness Through Awareness\" for a more detailed discussion of individual fairness.",
    "inference": "#fundamentals\nIn machine learning, the process of making predictions by applying a trained model to unlabeled examples.\n\nInference has a somewhat different meaning in statistics. See the Wikipedia article on statistical inference for details.\n\nSee Supervised Learning in the Intro to ML course to see inference's role in a supervised learning system.",
    "inference path": "#df\nIn a decision tree, during inference, the route a particular example takes from the root to other conditions, terminating with a leaf. For example, in the following decision tree, the thicker arrows show the inference path for an example with the following feature values:\n\nx = 7\ny = 12\nz = -3\nThe inference path in the following illustration travels through three conditions before reaching the leaf (Zeta).\n\nA decision tree consisting of four conditions and five leaves.\n          The root condition is (x > 0). Since the answer is Yes, the\n          inference path travels from the root to the next condition (y > 0).\n          Since the answer is Yes, the inference path then travels to the\n          next condition (z > 0). Since the answer is No, the inference path\n          travels to its terminal node, which is the leaf (Zeta).\n\nThe three thick arrows show the inference path.\n\nSee Decision trees in the Decision Forests course for more information.",
    "information gain": "#df#Metric\nIn decision forests, the difference between a node's entropy and the weighted (by number of examples) sum of the entropy of its children nodes. A node's entropy is the entropy of the examples in that node.\n\nFor example, consider the following entropy values:\n\nentropy of parent node = 0.6\nentropy of one child node with 16 relevant examples = 0.2\nentropy of another child node with 24 relevant examples = 0.1\nSo 40% of the examples are in one child node and 60% are in the other child node. Therefore:\n\nweighted entropy sum of child nodes = (0.4 * 0.2) + (0.6 * 0.1) = 0.14\nSo, the information gain is:\n\ninformation gain = entropy of parent node - weighted entropy sum of child nodes\ninformation gain = 0.6 - 0.14 = 0.46\nMost splitters seek to create conditions that maximize information gain.",
    "in-group bias": "#fairness\nShowing partiality to one's own group or own characteristics. If testers or raters consist of the machine learning developer's friends, family, or colleagues, then in-group bias may invalidate product testing or the dataset.\n\nIn-group bias is a form of group attribution bias. See also out-group homogeneity bias.\n\nSee Fairness: Types of bias in Machine Learning Crash Course for more information.",
    "input generator": "A mechanism by which data is loaded into a neural network.\n\nAn input generator can be thought of as a component responsible for processing raw data into tensors which are iterated over to generate batches for training, evaluation, and inference.",
    "input layer": "#fundamentals\nThe layer of a neural network that holds the feature vector. That is, the input layer provides examples for training or inference. For example, the input layer in the following neural network consists of two features:\n\nFour layers: an input layer, two hidden layers, and an output layer.",
    "in-set condition": "#df\nIn a decision tree, a condition that tests for the presence of one item in a set of items. For example, the following is an in-set condition:\n\n  house-style in [tudor, colonial, cape]\nDuring inference, if the value of the house-style feature is tudor or colonial or cape, then this condition evaluates to Yes. If the value of the house-style feature is something else (for example, ranch), then this condition evaluates to No.\n\nIn-set conditions usually lead to more efficient decision trees than conditions that test one-hot encoded features.",
    "instance": "Synonym for example.",
    "instruction tuning": "#generativeAI\nA form of fine-tuning that improves a generative AI model's ability to follow instructions. Instruction tuning involves training a model on a series of instruction prompts, typically covering a wide variety of tasks. The resulting instruction-tuned model then tends to generate useful responses to zero-shot prompts across a variety of tasks.\n\nCompare and contrast with:\n\nparameter-efficient tuning\nprompt tuning",
    "interpretability": "#fundamentals\nThe ability to explain or to present an ML model's reasoning in understandable terms to a human.\n\nMost linear regression models, for example, are highly interpretable. (You merely need to look at the trained weights for each feature.) Decision forests are also highly interpretable. Some models, however, require sophisticated visualization to become interpretable.\n\nYou can use the Learning Interpretability Tool (LIT) to interpret ML models.",
    "inter-rater agreement": "#Metric\nA measurement of how often human raters agree when doing a task. If raters disagree, the task instructions may need to be improved. Also sometimes called inter-annotator agreement or inter-rater reliability. See also Cohen's kappa, which is one of the most popular inter-rater agreement measurements.\n\nSee Categorical data: Common issues in Machine Learning Crash Course for more information.",
    "intersection over union (IoU)": "#image\nThe intersection of two sets divided by their union. In machine-learning image-detection tasks, IoU is used to measure the accuracy of the model's predicted bounding box with respect to the ground-truth bounding box. In this case, the IoU for the two boxes is the ratio between the overlapping area and the total area, and its value ranges from 0 (no overlap of predicted bounding box and ground-truth bounding box) to 1 (predicted bounding box and ground-truth bounding box have the exact same coordinates).\n\nFor example, in the image below:\n\nThe predicted bounding box (the coordinates delimiting where the model predicts the night table in the painting is located) is outlined in purple.\nThe ground-truth bounding box (the coordinates delimiting where the night table in the painting is actually located) is outlined in green.\nThe Van Gogh painting Vincent's Bedroom in Arles, with two different\n          bounding boxes around the night table beside the bed. The ground-truth\n          bounding box (in green) perfectly circumscribes the night table. The\n          predicted bounding box (in purple) is offset 50% down and to the right\n          of the ground-truth bounding box; it encloses the bottom-right quarter\n          of the night table, but misses the rest of the table.\n\nHere, the intersection of the bounding boxes for prediction and ground truth (below left) is 1, and the union of the bounding boxes for prediction and ground truth (below right) is 7, so the IoU is \n.\n\nSame image as above, but with each bounding box divided into four\n          quadrants. There are seven quadrants total, as the bottom-right\n          quadrant of the ground-truth bounding box and the top-left\n          quadrant of the predicted bounding box overlap each other. This\n          overlapping section (highlighted in green) represents the\n          intersection, and has an area of 1. Same image as above, but with each bounding box divided into four\n          quadrants. There are seven quadrants total, as the bottom-right\n          quadrant of the ground-truth bounding box and the top-left\n          quadrant of the predicted bounding box overlap each other.\n          The entire interior enclosed by both bounding boxes\n          (highlighted in green) represents the union, and has\n          an area of 7.",
    "IoU": "Abbreviation for intersection over union.",
    "item matrix": "#recsystems\nIn recommendation systems, a matrix of embedding vectors generated by matrix factorization that holds latent signals about each item. Each row of the item matrix holds the value of a single latent feature for all items. For example, consider a movie recommendation system. Each column in the item matrix represents a single movie. The latent signals might represent genres, or might be harder-to-interpret signals that involve complex interactions among genre, stars, movie age, or other factors.\n\nThe item matrix has the same number of columns as the target matrix that is being factorized. For example, given a movie recommendation system that evaluates 10,000 movie titles, the item matrix will have 10,000 columns.",
    "items": "#recsystems\nIn a recommendation system, the entities that a system recommends. For example, videos are the items that a video store recommends, while books are the items that a bookstore recommends.",
    "iteration": "#fundamentals\nA single update of a model's parameters\u2014the model's weights and biases\u2014during training. The batch size determines how many examples the model processes in a single iteration. For instance, if the batch size is 20, then the model processes 20 examples before adjusting the parameters.\n\nWhen training a neural network, a single iteration involves the following two passes:\n\nA forward pass to evaluate loss on a single batch.\nA backward pass (backpropagation) to adjust the model's parameters based on the loss and the learning rate.\nSee Gradient descent in Machine Learning Crash Course for more information.\n\n\nJ",
    "JAX": "An array computing library, bringing together XLA (Accelerated Linear Algebra) and automatic differentiation for high-performance numerical computing. JAX provides a simple and powerful API for writing accelerated numerical code with composable transformations. JAX provides features such as:\n\ngrad (automatic differentiation)\njit (just-in-time compilation)\nvmap (automatic vectorization or batching)\npmap (parallelization)\nJAX is a language for expressing and composing transformations of numerical code, analogous\u2014but much larger in scope\u2014to Python's NumPy library. (In fact, the .numpy library under JAX is a functionally equivalent, but entirely rewritten version of the Python NumPy library.)\n\nJAX is particularly well-suited for speeding up many machine learning tasks by transforming the models and data into a form suitable for parallelism across GPU and TPU accelerator chips.\n\nFlax, Optax, Pax, and many other libraries are built on the JAX infrastructure.\n\n\nK",
    "Keras": "A popular Python machine learning API. Keras runs on several deep learning frameworks, including TensorFlow, where it is made available as tf.keras.",
    "Kernel Support Vector Machines (KSVMs)": "A classification algorithm that seeks to maximize the margin between positive and negative classes by mapping input data vectors to a higher dimensional space. For example, consider a classification problem in which the input dataset has a hundred features. To maximize the margin between positive and negative classes, a KSVM could internally map those features into a million-dimension space. KSVMs uses a loss function called hinge loss.",
    "keypoints": "#image\nThe coordinates of particular features in an image. For example, for an image recognition model that distinguishes flower species, keypoints might be the center of each petal, the stem, the stamen, and so on.",
    "k-fold cross validation": "An algorithm for predicting a model's ability to generalize to new data. The k in k-fold refers to the number of equal groups you divide a dataset's examples into; that is, you train and test your model k times. For each round of training and testing, a different group is the test set, and all remaining groups become the training set. After k rounds of training and testing, you calculate the mean and standard deviation of the chosen test metric(s).\n\nFor example, suppose your dataset consists of 120 examples. Further suppose, you decide to set k to 4. Therefore, after shuffling the examples, you divide the dataset into four equal groups of 30 examples and conduct four training and testing rounds:\n\nA dataset broken into four equal groups of examples. In Round 1,\n          the first three groups are used for training and the last group\n          is used for testing. In Round 2, the first two groups and the last\n          group are used for training, while the third group is used for\n          testing. In Round 3, the first group and the last two groups are\n          used for training, while the second group is used for testing.\n          In Round 4, the first group is used is for testing, while the final\n          three groups are used for training.\n\nFor example, Mean Squared Error (MSE) might be the most meaningful metric for a linear regression model. Therefore, you would find the mean and standard deviation of the MSE across all four rounds.",
    "k-means": "#clustering\nA popular clustering algorithm that groups examples in unsupervised learning. The k-means algorithm basically does the following:\n\nIteratively determines the best k center points (known as centroids).\nAssigns each example to the closest centroid. Those examples nearest the same centroid belong to the same group.\nThe k-means algorithm picks centroid locations to minimize the cumulative square of the distances from each example to its closest centroid.\n\nFor example, consider the following plot of dog height to dog width:\n\nA Cartesian plot with several dozen data points.\n\nIf k=3, the k-means algorithm will determine three centroids. Each example is assigned to its closest centroid, yielding three groups:\n\nThe same Cartesian plot as in the previous illustration, except\n          with three centroids added.\n          The previous data points are clustered into three distinct groups,\n          with each group representing the data points closest to a particular\n          centroid.\n\nImagine that a manufacturer wants to determine the ideal sizes for small, medium, and large sweaters for dogs. The three centroids identify the mean height and mean width of each dog in that cluster. So, the manufacturer should probably base sweater sizes on those three centroids. Note that the centroid of a cluster is typically not an example in the cluster.\n\nThe preceding illustrations shows k-means for examples with only two features (height and width). Note that k-means can group examples across many features.\n\nSee What is k-means clustering? in the Clustering course for more information.",
    "k-median": "#clustering\nA clustering algorithm closely related to k-means. The practical difference between the two is as follows:\n\nIn k-means, centroids are determined by minimizing the sum of the squares of the distance between a centroid candidate and each of its examples.\nIn k-median, centroids are determined by minimizing the sum of the distance between a centroid candidate and each of its examples.\nNote that the definitions of distance are also different:\n\nk-means relies on the Euclidean distance from the centroid to an example. (In two dimensions, the Euclidean distance means using the Pythagorean theorem to calculate the hypotenuse.) For example, the k-means distance between (2,2) and (5,-2) would be:\nk-median relies on the Manhattan distance from the centroid to an example. This distance is the sum of the absolute deltas in each dimension. For example, the k-median distance between (2,2) and (5,-2) would be:\n\nL",
    "L0 regularization": "#fundamentals\nA type of regularization that penalizes the total number of nonzero weights in a model. For example, a model having 11 nonzero weights would be penalized more than a similar model having 10 nonzero weights.\n\nL0 regularization is sometimes called L0-norm regularization.\n\n Click the icon for additional notes.",
    "L1 loss": "#fundamentals#Metric\nA loss function that calculates the absolute value of the difference between actual label values and the values that a model predicts. For example, here's the calculation of L1 loss for a batch of five examples:\n\nActual value of example\tModel's predicted value\tAbsolute value of delta\n7\t6\t1\n5\t4\t1\n8\t11\t3\n4\t6\t2\n9\t8\t1\n \t8 = L1 loss\nL1 loss is less sensitive to outliers than L2 loss.\n\nThe Mean Absolute Error is the average L1 loss per example.\n\n Click the icon to see the formal math.\nSee Linear regression: Loss in Machine Learning Crash Course for more information.",
    "L1 regularization": "#fundamentals\nA type of regularization that penalizes weights in proportion to the sum of the absolute value of the weights. L1 regularization helps drive the weights of irrelevant or barely relevant features to exactly 0. A feature with a weight of 0 is effectively removed from the model.\n\nContrast with L2 regularization.",
    "L2 loss": "#fundamentals#Metric\nA loss function that calculates the square of the difference between actual label values and the values that a model predicts. For example, here's the calculation of L2 loss for a batch of five examples:\n\nActual value of example\tModel's predicted value\tSquare of delta\n7\t6\t1\n5\t4\t1\n8\t11\t9\n4\t6\t4\n9\t8\t1\n \t16 = L2 loss\nDue to squaring, L2 loss amplifies the influence of outliers. That is, L2 loss reacts more strongly to bad predictions than L1 loss. For example, the L1 loss for the preceding batch would be 8 rather than 16. Notice that a single outlier accounts for 9 of the 16.\n\nRegression models typically use L2 loss as the loss function.\n\nThe Mean Squared Error is the average L2 loss per example. Squared loss is another name for L2 loss.\n\n Click the icon to see the formal math.\nSee Logistic regression: Loss and regularization in Machine Learning Crash Course for more information.",
    "L2 regularization": "#fundamentals\nA type of regularization that penalizes weights in proportion to the sum of the squares of the weights. L2 regularization helps drive outlier weights (those with high positive or low negative values) closer to 0 but not quite to 0. Features with values very close to 0 remain in the model but don't influence the model's prediction very much.\n\nL2 regularization always improves generalization in linear models.\n\nContrast with L1 regularization.\n\nSee Overfitting: L2 regularization in Machine Learning Crash Course for more information.",
    "label": "#fundamentals\nIn supervised machine learning, the \"answer\" or \"result\" portion of an example.\n\nEach labeled example consists of one or more features and a label. For example, in a spam detection dataset, the label would probably be either \"spam\" or \"not spam.\" In a rainfall dataset, the label might be the amount of rain that fell during a certain period.\n\nSee Supervised Learning in Introduction to Machine Learning for more information.\n\n\nlabeled example\n#fundamentals\nAn example that contains one or more features and a label. For example, the following table shows three labeled examples from a house valuation model, each with three features and one label:\n\nNumber of bedrooms\tNumber of bathrooms\tHouse age\tHouse price (label)\n3\t2\t15\t$345,000\n2\t1\t72\t$179,000\n4\t2\t34\t$392,000\nIn supervised machine learning, models train on labeled examples and make predictions on unlabeled examples.\n\nContrast labeled example with unlabeled examples.\n\nSee Supervised Learning in Introduction to Machine Learning for more information.",
    "label leakage": "A model design flaw in which a feature is a proxy for the label. For example, consider a binary classification model that predicts whether or not a prospective customer will purchase a particular product. Suppose that one of the features for the model is a Boolean named SpokeToCustomerAgent. Further suppose that a customer agent is only assigned after the prospective customer has actually purchased the product. During training, the model will quickly learn the association between SpokeToCustomerAgent and the label.\n\nSee Monitoring pipelines in Machine Learning Crash Course for more information.",
    "lambda": "#fundamentals\nSynonym for regularization rate.\n\nLambda is an overloaded term. Here we're focusing on the term's definition within regularization.",
    "LaMDA (Language Model for Dialogue Applications)": "#language\nA Transformer-based large language model developed by Google trained on a large dialogue dataset that can generate realistic conversational responses.\n\nLaMDA: our breakthrough conversation technology provides an overview.",
    "landmarks": "#image\nSynonym for keypoints.",
    "language model": "#language\nA model that estimates the probability of a token or sequence of tokens occurring in a longer sequence of tokens.\n\n Click the icon for additional notes.\nSee What is a language model? in Machine Learning Crash Course for more information.",
    "large language model": "#language\nAt a minimum, a language model having a very high number of parameters. More informally, any Transformer-based language model, such as Gemini or GPT.\n\nSee Large language models (LLMs) in Machine Learning Crash Course for more information.",
    "latent space": "#language\nSynonym for embedding space.",
    "layer": "#fundamentals\nA set of neurons in a neural network. Three common types of layers are as follows:\n\nThe input layer, which provides values for all the features.\nOne or more hidden layers, which find nonlinear relationships between the features and the label.\nThe output layer, which provides the prediction.\nFor example, the following illustration shows a neural network with one input layer, two hidden layers, and one output layer:\n\nA neural network with one input layer, two hidden layers, and one\n          output layer. The input layer consists of two features. The first\n          hidden layer consists of three neurons and the second hidden layer\n          consists of two neurons. The output layer consists of a single node.\n\nIn TensorFlow, layers are also Python functions that take Tensors and configuration options as input and produce other tensors as output.",
    "Layers API (tf.layers)": "#TensorFlow\nA TensorFlow API for constructing a deep neural network as a composition of layers. The Layers API lets you build different types of layers, such as:\n\ntf.layers.Dense for a fully-connected layer.\ntf.layers.Conv2D for a convolutional layer.\nThe Layers API follows the Keras layers API conventions. That is, aside from a different prefix, all functions in the Layers API have the same names and signatures as their counterparts in the Keras layers API.",
    "leaf": "#df\nAny endpoint in a decision tree. Unlike a condition, a leaf doesn't perform a test. Rather, a leaf is a possible prediction. A leaf is also the terminal node of an inference path.\n\nFor example, the following decision tree contains three leaves:\n\nA decision tree with two conditions leading to three leaves.\n\nSee Decision trees in the Decision Forests course for more information.",
    "Learning Interpretability Tool (LIT)": "A visual, interactive model-understanding and data visualization tool.\n\nYou can use open-source LIT to interpret models or to visualize text, image, and tabular data.",
    "learning rate": "#fundamentals\nA floating-point number that tells the gradient descent algorithm how strongly to adjust weights and biases on each iteration. For example, a learning rate of 0.3 would adjust weights and biases three times more powerfully than a learning rate of 0.1.\n\nLearning rate is a key hyperparameter. If you set the learning rate too low, training will take too long. If you set the learning rate too high, gradient descent often has trouble reaching convergence.\n\n Click the icon for a more mathematical explanation.\nSee Linear regression: Hyperparameters in Machine Learning Crash Course for more information.",
    "least squares regression": "A linear regression model trained by minimizing L2 Loss.",
    "Levenshtein Distance": "#language#metric\nAn edit distance metric that calculates the fewest delete, insert, and substitute operations required to change one word to another. For example, the Levenshtein distance between the words \"heart\" and \"darts\" is three because the following three edits are the fewest changes to turn one word into the other:\n\nheart \u2192 deart (substitute \"h\" with \"d\")\ndeart \u2192 dart (delete \"e\")\ndart \u2192 darts (insert \"s\")\nNote that the preceding sequence isn't the only path of three edits.",
    "linear": "#fundamentals\nA relationship between two or more variables that can be represented solely through addition and multiplication.\n\nThe plot of a linear relationship is a line.\n\nContrast with nonlinear.",
    "linear model": "#fundamentals\nA model that assigns one weight per feature to make predictions. (Linear models also incorporate a bias.) In contrast, the relationship of features to predictions in deep models is generally nonlinear.\n\nLinear models are usually easier to train and more interpretable than deep models. However, deep models can learn complex relationships between features.\n\nLinear regression and logistic regression are two types of linear models.\n\n Click the icon to see the math.",
    "linear regression": "#fundamentals\nA type of machine learning model in which both of the following are true:\n\nThe model is a linear model.\nThe prediction is a floating-point value. (This is the regression part of linear regression.)\nContrast linear regression with logistic regression. Also, contrast regression with classification.\n\nSee Linear regression in Machine Learning Crash Course for more information.",
    "LIT": "Abbreviation for the Learning Interpretability Tool (LIT), which was previously known as the Language Interpretability Tool.",
    "LLM": "#language#generativeAI\nAbbreviation for large language model.",
    "LLM evaluations (evals)": "#language#generativeAI#Metric\nA set of metrics and benchmarks for assessing the performance of large language models (LLMs). At a high level, LLM evaluations:\n\nHelp researchers identify areas where LLMs need improvement.\nAre useful in comparing different LLMs and identifying the best LLM for a particular task.\nHelp ensure that LLMs are safe and ethical to use.\nSee Large language models (LLMs) in Machine Learning Crash Course for more information.",
    "logistic regression": "#fundamentals\nA type of regression model that predicts a probability. Logistic regression models have the following characteristics:\n\nThe label is categorical. The term logistic regression usually refers to binary logistic regression, that is, to a model that calculates probabilities for labels with two possible values. A less common variant, multinomial logistic regression, calculates probabilities for labels with more than two possible values.\nThe loss function during training is Log Loss. (Multiple Log Loss units can be placed in parallel for labels with more than two possible values.)\nThe model has a linear architecture, not a deep neural network. However, the remainder of this definition also applies to deep models that predict probabilities for categorical labels.\nFor example, consider a logistic regression model that calculates the probability of an input email being either spam or not spam. During inference, suppose the model predicts 0.72. Therefore, the model is estimating:\n\nA 72% chance of the email being spam.\nA 28% chance of the email not being spam.\nA logistic regression model uses the following two-step architecture:\n\nThe model generates a raw prediction (y') by applying a linear function of input features.\nThe model uses that raw prediction as input to a sigmoid function, which converts the raw prediction to a value between 0 and 1, exclusive.\nLike any regression model, a logistic regression model predicts a number. However, this number typically becomes part of a binary classification model as follows:\n\nIf the predicted number is greater than the classification threshold, the binary classification model predicts the positive class.\nIf the predicted number is less than the classification threshold, the binary classification model predicts the negative class.\nSee Logistic regression in Machine Learning Crash Course for more information.",
    "logits": "The vector of raw (non-normalized) predictions that a classification model generates, which is ordinarily then passed to a normalization function. If the model is solving a multi-class classification problem, logits typically become an input to the softmax function. The softmax function then generates a vector of (normalized) probabilities with one value for each possible class.",
    "Log Loss": "#fundamentals\nThe loss function used in binary logistic regression.\n\n Click the icon to see the math.\nSee Logistic regression: Loss and regularization in Machine Learning Crash Course for more information.",
    "log-odds": "#fundamentals\nThe logarithm of the odds of some event.\n\n Click the icon to see the math.",
    "Long Short-Term Memory (LSTM)": "#seq\nA type of cell in a recurrent neural network used to process sequences of data in applications such as handwriting recognition, machine translation, and image captioning. LSTMs address the vanishing gradient problem that occurs when training RNNs due to long data sequences by maintaining history in an internal memory state based on new input and context from previous cells in the RNN.",
    "LoRA": "#language#generativeAI\nAbbreviation for Low-Rank Adaptability.",
    "loss": "#fundamentals#Metric\nDuring the training of a supervised model, a measure of how far a model's prediction is from its label.\n\nA loss function calculates the loss.\n\nSee Linear regression: Loss in Machine Learning Crash Course for more information.",
    "loss aggregator": "A type of machine learning algorithm that improves the performance of a model by combining the predictions of multiple models and using those predictions to make a single prediction. As a result, a loss aggregator can reduce the variance of the predictions and improve the accuracy of the predictions.",
    "loss curve": "#fundamentals\nA plot of loss as a function of the number of training iterations. The following plot shows a typical loss curve:\n\nA Cartesian graph of loss versus training iterations, showing a\n          rapid drop in loss for the initial iterations, followed by a gradual\n          drop, and then a flat slope during the final iterations.\n\nLoss curves can help you determine when your model is converging or overfitting.\n\nLoss curves can plot all of the following types of loss:\n\ntraining loss\nvalidation loss\ntest loss\nSee also generalization curve.\n\nSee Overfitting: Interpreting loss curves in Machine Learning Crash Course for more information.",
    "loss function": "#fundamentals#Metric\nDuring training or testing, a mathematical function that calculates the loss on a batch of examples. A loss function returns a lower loss for models that makes good predictions than for models that make bad predictions.\n\nThe goal of training is typically to minimize the loss that a loss function returns.\n\nMany different kinds of loss functions exist. Pick the appropriate loss function for the kind of model you are building. For example:\n\nL2 loss (or Mean Squared Error) is the loss function for linear regression.\nLog Loss is the loss function for logistic regression.",
    "loss surface": "A graph of weight(s) versus loss. Gradient descent aims to find the weight(s) for which the loss surface is at a local minimum.",
    "Low-Rank Adaptability (LoRA)": "#language#generativeAI\nA parameter-efficient technique for fine tuning that \"freezes\" the model's pre-trained weights (such that they can no longer be modified) and then inserts a small set of trainable weights into the model. This set of trainable weights (also known as \"update matrixes\") is considerably smaller than the base model and is therefore much faster to train.\n\nLoRA provides the following benefits:\n\nImproves the quality of a model's predictions for the domain where the fine tuning is applied.\nFine-tunes faster than techniques that require fine-tuning all of a model's parameters.\nReduces the computational cost of inference by enabling concurrent serving of multiple specialized models sharing the same base model.\n Click the icon to learn more about update matrixes in LoRA.",
    "LSTM": "#seq\nAbbreviation for Long Short-Term Memory.\n\n\nM",
    "machine learning": "#fundamentals\nA program or system that trains a model from input data. The trained model can make useful predictions from new (never-before-seen) data drawn from the same distribution as the one used to train the model.\n\nMachine learning also refers to the field of study concerned with these programs or systems.\n\nSee the Introduction to Machine Learning course for more information.",
    "machine translation": "#generativeAI\nUsing software (typically, a machine learning model) to convert text from one human language to another human language, for example, from English to Japanese.",
    "majority class": "#fundamentals\nThe more common label in a class-imbalanced dataset. For example, given a dataset containing 99% negative labels and 1% positive labels, the negative labels are the majority class.\n\nContrast with minority class.\n\nSee Datasets: Imbalanced datasets in Machine Learning Crash Course for more information.",
    "Markov decision process (MDP)": "#rl\nA graph representing the decision-making model where decisions (or actions) are taken to navigate a sequence of states under the assumption that the Markov property holds. In reinforcement learning, these transitions between states return a numerical reward.",
    "Markov property": "#rl\nA property of certain environments, where state transitions are entirely determined by information implicit in the current state and the agent's action.",
    "masked language model": "#language\nA language model that predicts the probability of candidate tokens to fill in blanks in a sequence. For example, a masked language model can calculate probabilities for candidate word(s) to replace the underline in the following sentence:\n\nThe ____ in the hat came back.\n\nThe literature typically uses the string \"MASK\" instead of an underline. For example:\n\nThe \"MASK\" in the hat came back.\n\nMost modern masked language models are bidirectional.",
    "matplotlib": "An open-source Python 2D plotting library. matplotlib helps you visualize different aspects of machine learning.",
    "matrix factorization": "#recsystems\nIn math, a mechanism for finding the matrixes whose dot product approximates a target matrix.\n\nIn recommendation systems, the target matrix often holds users' ratings on items. For example, the target matrix for a movie recommendation system might look something like the following, where the positive integers are user ratings and 0 means that the user didn't rate the movie:\n\n \tCasablanca\tThe Philadelphia Story\tBlack Panther\tWonder Woman\tPulp Fiction\nUser 1\t5.0\t3.0\t0.0\t2.0\t0.0\nUser 2\t4.0\t0.0\t0.0\t1.0\t5.0\nUser 3\t3.0\t1.0\t4.0\t5.0\t0.0\nThe movie recommendation system aims to predict user ratings for unrated movies. For example, will User 1 like Black Panther?\n\nOne approach for recommendation systems is to use matrix factorization to generate the following two matrixes:\n\nA user matrix, shaped as the number of users X the number of embedding dimensions.\nAn item matrix, shaped as the number of embedding dimensions X the number of items.\nFor example, using matrix factorization on our three users and five items could yield the following user matrix and item matrix:\n\n\nUser Matrix                 Item Matrix\n\n1.1   2.3           0.9   0.2   1.4    2.0   1.2\n0.6   2.0           1.7   1.2   1.2   -0.1   2.1\n2.5   0.5\nThe dot product of the user matrix and item matrix yields a recommendation matrix that contains not only the original user ratings but also predictions for the movies that each user hasn't seen. For example, consider User 1's rating of Casablanca, which was 5.0. The dot product corresponding to that cell in the recommendation matrix should hopefully be around 5.0, and it is:\n\n(1.1 * 0.9) + (2.3 * 1.7) = 4.9\nMore importantly, will User 1 like Black Panther? Taking the dot product corresponding to the first row and the third column yields a predicted rating of 4.3:\n\n(1.1 * 1.4) + (2.3 * 1.2) = 4.3\nMatrix factorization typically yields a user matrix and item matrix that, together, are significantly more compact than the target matrix.",
    "Mean Absolute Error (MAE)": "#Metric\nThe average loss per example when L1 loss is used. Calculate Mean Absolute Error as follows:\n\nCalculate the L1 loss for a batch.\nDivide the L1 loss by the number of examples in the batch.\n Click the icon to see the formal math.\nFor example, consider the calculation of L1 loss on the following batch of five examples:\n\nActual value of example\tModel's predicted value\tLoss (difference between actual and predicted)\n7\t6\t1\n5\t4\t1\n8\t11\t3\n4\t6\t2\n9\t8\t1\n \t8 = L1 loss\nSo, L1 loss is 8 and the number of examples is 5. Therefore, the Mean Absolute Error is:\n\nMean Absolute Error = L1 loss / Number of Examples\nMean Absolute Error = 8/5 = 1.6\nContrast Mean Absolute Error with Mean Squared Error and Root Mean Squared Error.",
    "mean average precision at k (mAP@k)": "#language#generativeAI#Metric\nThe statistical mean of all average precision at k scores across a validation dataset. One use of mean average precision at k is to judge the quality of recommendations generated by a recommendation system.\n\nAlthough the phrase \"mean average\" sounds redundant, the name of the metric is appropriate. After all, this metric finds the mean of multiple average precision at k values.\n\n Click the icon to see an example.",
    "Mean Squared Error (MSE)": "#Metric\nThe average loss per example when L2 loss is used. Calculate Mean Squared Error as follows:\n\nCalculate the L2 loss for a batch.\nDivide the L2 loss by the number of examples in the batch.\n Click the icon to see the formal math.\nFor example, consider the loss on the following batch of five examples:\n\nActual value\tModel's prediction\tLoss\tSquared loss\n7\t6\t1\t1\n5\t4\t1\t1\n8\t11\t3\t9\n4\t6\t2\t4\n9\t8\t1\t1\n16 = L2 loss\nTherefore, the Mean Squared Error is:\n\nMean Squared Error = L2 loss / Number of Examples\nMean Squared Error = 16/5 = 3.2\nMean Squared Error is a popular training optimizer, particularly for linear regression.\n\nContrast Mean Squared Error with Mean Absolute Error and Root Mean Squared Error.\n\nTensorFlow Playground uses Mean Squared Error to calculate loss values.\n\n Click the icon to see more details about outliers.",
    "mesh": "#TensorFlow#GoogleCloud\nIn ML parallel programming, a term associated with assigning the data and model to TPU chips, and defining how these values will be sharded or replicated.\n\nMesh is an overloaded term that can mean either of the following:\n\nA physical layout of TPU chips.\nAn abstract logical construct for mapping the data and model to the TPU chips.\nIn either case, a mesh is specified as a shape.",
    "meta-learning": "#language\nA subset of machine learning that discovers or improves a learning algorithm. A meta-learning system can also aim to train a model to quickly learn a new task from a small amount of data or from experience gained in previous tasks. Meta-learning algorithms generally try to achieve the following:\n\nImprove or learn hand-engineered features (such as an initializer or an optimizer).\nBe more data-efficient and compute-efficient.\nImprove generalization.\nMeta-learning is related to few-shot learning.",
    "metric": "#TensorFlow#Metric\nA statistic that you care about.\n\nAn objective is a metric that a machine learning system tries to optimize.",
    "Metrics API (tf.metrics)": "#Metric\nA TensorFlow API for evaluating models. For example, tf.metrics.accuracy determines how often a model's predictions match labels.",
    "mini-batch": "#fundamentals\nA small, randomly selected subset of a batch processed in one iteration. The batch size of a mini-batch is usually between 10 and 1,000 examples.\n\nFor example, suppose the entire training set (the full batch) consists of 1,000 examples. Further suppose that you set the batch size of each mini-batch to 20. Therefore, each iteration determines the loss on a random 20 of the 1,000 examples and then adjusts the weights and biases accordingly.\n\nIt is much more efficient to calculate the loss on a mini-batch than the loss on all the examples in the full batch.\n\nSee Linear regression: Hyperparameters in Machine Learning Crash Course for more information.",
    "mini-batch stochastic gradient descent": "A gradient descent algorithm that uses mini-batches. In other words, mini-batch stochastic gradient descent estimates the gradient based on a small subset of the training data. Regular stochastic gradient descent uses a mini-batch of size 1.",
    "minimax loss": "#Metric\nA loss function for generative adversarial networks, based on the cross-entropy between the distribution of generated data and real data.\n\nMinimax loss is used in the first paper to describe generative adversarial networks.\n\nSee Loss Functions in the Generative Adversarial Networks course for more information.",
    "minority class": "#fundamentals\nThe less common label in a class-imbalanced dataset. For example, given a dataset containing 99% negative labels and 1% positive labels, the positive labels are the minority class.\n\nContrast with majority class.\n\n Click the icon for additional notes.\nSee Datasets: Imbalanced datasets in Machine Learning Crash Course for more information.",
    "mixture of experts": "#language#generativeAI\nA scheme to increase neural network efficiency by using only a subset of its parameters (known as an expert) to process a given input token or example. A gating network routes each input token or example to the proper expert(s).\n\nFor details, see either of the following papers:\n\nOutrageously Large Neural Networks: The Sparsely-Gated Mixture-of-Experts Layer\nMixture-of-Experts with Expert Choice Routing",
    "ML": "Abbreviation for machine learning.",
    "MMIT": "#language#image#generativeAI\nAbbreviation for multimodal instruction-tuned.",
    "MNIST": "#image\nA public-domain dataset compiled by LeCun, Cortes, and Burges containing 60,000 images, each image showing how a human manually wrote a particular digit from 0\u20139. Each image is stored as a 28x28 array of integers, where each integer is a grayscale value between 0 and 255, inclusive.\n\nMNIST is a canonical dataset for machine learning, often used to test new machine learning approaches. For details, see The MNIST Database of Handwritten Digits.",
    "modality": "#language\nA high-level data category. For example, numbers, text, images, video, and audio are five different modalities.",
    "model": "#fundamentals\nIn general, any mathematical construct that processes input data and returns output. Phrased differently, a model is the set of parameters and structure needed for a system to make predictions. In supervised machine learning, a model takes an example as input and infers a prediction as output. Within supervised machine learning, models differ somewhat. For example:\n\nA linear regression model consists of a set of weights and a bias.\nA neural network model consists of:\nA set of hidden layers, each containing one or more neurons.\nThe weights and bias associated with each neuron.\nA decision tree model consists of:\nThe shape of the tree; that is, the pattern in which the conditions and leaves are connected.\nThe conditions and leaves.\nYou can save, restore, or make copies of a model.\n\nUnsupervised machine learning also generates models, typically a function that can map an input example to the most appropriate cluster.\n\n Click the icon to compare algebraic and programming functions to ML models.",
    "model capacity": "#Metric\nThe complexity of problems that a model can learn. The more complex the problems that a model can learn, the higher the model's capacity. A model's capacity typically increases with the number of model parameters. For a formal definition of classification model capacity, see VC dimension.",
    "model cascading": "#generativeAI\nA system that picks the ideal model for a specific inference query.\n\nImagine a group of models, ranging from very large (lots of parameters) to much smaller (far fewer parameters). Very large models consume more computational resources at inference time than smaller models. However, very large models can typically infer more complex requests than smaller models. Model cascading determines the complexity of the inference query and then picks the appropriate model to perform the inference. The main motivation for model cascading is to reduce inference costs by generally selecting smaller models, and only selecting a larger model for more complex queries.\n\nImagine that a small model runs on a phone and a larger version of that model runs on a remote server. Good model cascading reduces cost and latency by enabling the smaller model to handle simple requests and only calling the remote model to handle complex requests.\n\nSee also model router.",
    "model parallelism": "#language\nA way of scaling training or inference that puts different parts of one model on different devices. Model parallelism enables models that are too big to fit on a single device.\n\nTo implement model parallelism, a system typically does the following:\n\nShards (divides) the model into smaller parts.\nDistributes the training of those smaller parts across multiple processors. Each processor trains its own part of the model.\nCombines the results to create a single model.\nModel parallelism slows training.\n\nSee also data parallelism.",
    "model router": "#generativeAI\nThe algorithm that determines the ideal model for inference in model cascading. A model router is itself typically a machine learning model that gradually learns how to pick the best model for a given input. However, a model router could sometimes be a simpler, non-machine learning algorithm.",
    "model training": "The process of determining the best model.",
    "MOE": "#language#image#generativeAI\nAbbreviation for mixture of experts.",
    "Momentum": "A sophisticated gradient descent algorithm in which a learning step depends not only on the derivative in the current step, but also on the derivatives of the step(s) that immediately preceded it. Momentum involves computing an exponentially weighted moving average of the gradients over time, analogous to momentum in physics. Momentum sometimes prevents learning from getting stuck in local minima.",
    "MT": "#generativeAI\nAbbreviation for machine translation.",
    "multi-class classification": "#fundamentals\nIn supervised learning, a classification problem in which the dataset contains more than two classes of labels. For example, the labels in the Iris dataset must be one of the following three classes:\n\nIris setosa\nIris virginica\nIris versicolor\nA model trained on the Iris dataset that predicts Iris type on new examples is performing multi-class classification.\n\nIn contrast, classification problems that distinguish between exactly two classes are binary classification models. For example, an email model that predicts either spam or not spam is a binary classification model.\n\nIn clustering problems, multi-class classification refers to more than two clusters.\n\nSee Neural networks: Multi-class classification in Machine Learning Crash Course for more information.",
    "multi-class logistic regression": "Using logistic regression in multi-class classification problems.",
    "multi-head self-attention": "#language\nAn extension of self-attention that applies the self-attention mechanism multiple times for each position in the input sequence.\n\nTransformers introduced multi-head self-attention.",
    "multimodal instruction-tuned": "#language\nAn instruction-tuned model that can process input beyond text, such as images, video, and audio.",
    "multimodal model": "#language\nA model whose inputs, outputs, or both include more than one modality. For example, consider a model that takes both an image and a text caption (two modalities) as features, and outputs a score indicating how appropriate the text caption is for the image. So, this model's inputs are multimodal and the output is unimodal.",
    "multinomial classification": "Synonym for multi-class classification.",
    "multinomial regression": "Synonym for multi-class logistic regression.",
    "multitask": "A machine learning technique in which a single model is trained to perform multiple tasks.\n\nMultitask models are created by training on data that is appropriate for each of the different tasks. This allows the model to learn to share information across the tasks, which helps the model learn more effectively.\n\nA model trained for multiple tasks often has improved generalization abilities and can be more robust at handling different types of data.\n\n\nN",
    "NaN trap": "When one number in your model becomes a NaN during training, which causes many or all other numbers in your model to eventually become a NaN.\n\nNaN is an abbreviation for Not a Number.",
    "natural language processing": "#languageThe field of teaching computers to process what a user said or typed using linguistic rules. Almost all modern natural language processing relies on machine learning.",
    "natural language understanding": "#language\nA subset of natural language processing that determines the intentions of something said or typed. Natural language understanding can go beyond natural language processing to consider complex aspects of language like context, sarcasm, and sentiment.",
    "negative class": "#fundamentals#Metric\nIn binary classification, one class is termed positive and the other is termed negative. The positive class is the thing or event that the model is testing for and the negative class is the other possibility. For example:\n\nThe negative class in a medical test might be \"not tumor.\"\nThe negative class in an email classification model might be \"not spam.\"\nContrast with positive class.",
    "negative sampling": "Synonym for candidate sampling.",
    "Neural Architecture Search (NAS)": "A technique for automatically designing the architecture of a neural network. NAS algorithms can reduce the amount of time and resources required to train a neural network.\n\nNAS typically uses:\n\nA search space, which is a set of possible architectures.\nA fitness function, which is a measure of how well a particular architecture performs on a given task.\nNAS algorithms often start with a small set of possible architectures and gradually expand the search space as the algorithm learns more about what architectures are effective. The fitness function is typically based on the performance of the architecture on a training set, and the algorithm is typically trained using a reinforcement learning technique.\n\nNAS algorithms have proven effective in finding high-performing architectures for a variety of tasks, including image classification, text classification, and machine translation.",
    "neural network": "#fundamentals\nA model containing at least one hidden layer. A deep neural network is a type of neural network containing more than one hidden layer. For example, the following diagram shows a deep neural network containing two hidden layers.\n\nA neural network with an input layer, two hidden layers, and an\n          output layer.\n\nEach neuron in a neural network connects to all of the nodes in the next layer. For example, in the preceding diagram, notice that each of the three neurons in the first hidden layer separately connect to both of the two neurons in the second hidden layer.\n\nNeural networks implemented on computers are sometimes called artificial neural networks to differentiate them from neural networks found in brains and other nervous systems.\n\nSome neural networks can mimic extremely complex nonlinear relationships between different features and the label.\n\nSee also convolutional neural network and recurrent neural network.\n\nSee Neural networks in Machine Learning Crash Course for more information.",
    "neuron": "#fundamentals\nIn machine learning, a distinct unit within a hidden layer of a neural network. Each neuron performs the following two-step action:\n\nCalculates the weighted sum of input values multiplied by their corresponding weights.\nPasses the weighted sum as input to an activation function.\nA neuron in the first hidden layer accepts inputs from the feature values in the input layer. A neuron in any hidden layer beyond the first accepts inputs from the neurons in the preceding hidden layer. For example, a neuron in the second hidden layer accepts inputs from the neurons in the first hidden layer.\n\nThe following illustration highlights two neurons and their inputs.\n\nA neural network with an input layer, two hidden layers, and an\n          output layer. Two neurons are highlighted: one in the first\n          hidden layer and one in the second hidden layer. The highlighted\n          neuron in the first hidden layer receives inputs from both features\n          in the input layer. The highlighted neuron in the second hidden layer\n          receives inputs from each of the three neurons in the first hidden\n          layer.\n\nA neuron in a neural network mimics the behavior of neurons in brains and other parts of nervous systems.",
    "N-gram": "#seq#language\nAn ordered sequence of N words. For example, truly madly is a 2-gram. Because order is relevant, madly truly is a different 2-gram than truly madly.\n\nN\tName(s) for this kind of N-gram\tExamples\n2\tbigram or 2-gram\tto go, go to, eat lunch, eat dinner\n3\ttrigram or 3-gram\tate too much, happily ever after, the bell tolls\n4\t4-gram\twalk in the park, dust in the wind, the boy ate lentils\nMany natural language understanding models rely on N-grams to predict the next word that the user will type or say. For example, suppose a user typed happily ever. An NLU model based on trigrams would likely predict that the user will next type the word after.\n\nContrast N-grams with bag of words, which are unordered sets of words.\n\nSee Large language models in Machine Learning Crash Course for more information.",
    "NLP": "#language\nAbbreviation for natural language processing.",
    "NLU": "#language\nAbbreviation for natural language understanding.\n\n\nnode (decision tree)\n#df\nIn a decision tree, any condition or leaf.\n\nA decision tree with two conditions and three leaves.\n\nSee Decision Trees in the Decision Forests course for more information.",
    "node (neural network)": "#fundamentals\nA neuron in a hidden layer.\n\nSee Neural Networks in Machine Learning Crash Course for more information.",
    "node (TensorFlow graph)": "#TensorFlow\nAn operation in a TensorFlow graph.",
    "noise": "Broadly speaking, anything that obscures the signal in a dataset. Noise can be introduced into data in a variety of ways. For example:\n\nHuman raters make mistakes in labeling.\nHumans and instruments mis-record or omit feature values.",
    "non-binary condition": "#df\nA condition containing more than two possible outcomes. For example, the following non-binary condition contains three possible outcomes:\n\nA condition (number_of_legs = ?) that leads to three possible\n          outcomes. One outcome (number_of_legs = 8) leads to a leaf\n          named spider. A second outcome (number_of_legs = 4) leads to\n          a leaf named dog. A third outcome (number_of_legs = 2) leads to\n          a leaf named penguin.\n\nSee Types of conditions in the Decision Forests course for more information.",
    "nonlinear": "#fundamentals\nA relationship between two or more variables that can't be represented solely through addition and multiplication. A linear relationship can be represented as a line; a nonlinear relationship can't be represented as a line. For example, consider two models that each relate a single feature to a single label. The model on the left is linear and the model on the right is nonlinear:\n\nTwo plots. One plot is a line, so this is a linear relationship.\n          The other plot is a curve, so this is a nonlinear relationship.\n\nSee Neural networks: Nodes and hidden layers in Machine Learning Crash Course to experiment with different kinds of nonlinear functions.",
    "non-response bias": "#fairness\nSee selection bias.",
    "nonstationarity": "#fundamentals\nA feature whose values change across one or more dimensions, usually time. For example, consider the following examples of nonstationarity:\n\nThe number of swimsuits sold at a particular store varies with the season.\nThe quantity of a particular fruit harvested in a particular region is zero for much of the year but large for a brief period.\nDue to climate change, annual mean temperatures are shifting.\nContrast with stationarity.",
    "no one right answer (NORA)": "#language#generativeAI\nA prompt having multiple appropriate responses. For example, the following prompt has no one right answer:\n\nTell me a joke about elephants.\n\nEvaluating no-one-right-answer prompts can be challenging.",
    "NORA": "#language#generativeAI\nAbbreviation for no one right answer.",
    "normalization": "#fundamentals\nBroadly speaking, the process of converting a variable's actual range of values into a standard range of values, such as:\n\n-1 to +1\n0 to 1\nZ-scores (roughly, -3 to +3)\nFor example, suppose the actual range of values of a certain feature is 800 to 2,400. As part of feature engineering, you could normalize the actual values down to a standard range, such as -1 to +1.\n\nNormalization is a common task in feature engineering. Models usually train faster (and produce better predictions) when every numerical feature in the feature vector has roughly the same range.\n\nSee also Z-score normalization.\n\nSee Numerical Data: Normalization in Machine Learning Crash Course for more information.",
    "novelty detection": "The process of determining whether a new (novel) example comes from the same distribution as the training set. In other words, after training on the training set, novelty detection determines whether a new example (during inference or during additional training) is an outlier.\n\nContrast with outlier detection.",
    "numerical data": "#fundamentals\nFeatures represented as integers or real-valued numbers. For example, a house valuation model would probably represent the size of a house (in square feet or square meters) as numerical data. Representing a feature as numerical data indicates that the feature's values have a mathematical relationship to the label. That is, the number of square meters in a house probably has some mathematical relationship to the value of the house.\n\nNot all integer data should be represented as numerical data. For example, postal codes in some parts of the world are integers; however, integer postal codes shouldn't be represented as numerical data in models. That's because a postal code of 20000 is not twice (or half) as potent as a postal code of 10000. Furthermore, although different postal codes do correlate to different real estate values, we can't assume that real estate values at postal code 20000 are twice as valuable as real estate values at postal code 10000. Postal codes should be represented as categorical data instead.\n\nNumerical features are sometimes called continuous features.\n\nSee Working with numerical data in Machine Learning Crash Course for more information.",
    "NumPy": "An open-source math library that provides efficient array operations in Python. pandas is built on NumPy.\n\n\nO",
    "objective": "#Metric\nA metric that your algorithm is trying to optimize.",
    "objective function": "#Metric\nThe mathematical formula or metric that a model aims to optimize. For example, the objective function for linear regression is usually Mean Squared Loss. Therefore, when training a linear regression model, training aims to minimize Mean Squared Loss.\n\nIn some cases, the goal is to maximize the objective function. For example, if the objective function is accuracy, the goal is to maximize accuracy.\n\nSee also loss.",
    "oblique condition": "#df\nIn a decision tree, a condition that involves more than one feature. For example, if height and width are both features, then the following is an oblique condition:\n\n  height > width\nContrast with axis-aligned condition.\n\nSee Types of conditions in the Decision Forests course for more information.",
    "offline": "#fundamentals\nSynonym for static.",
    "offline inference": "#fundamentals\nThe process of a model generating a batch of predictions and then caching (saving) those predictions. Apps can then access the inferred prediction from the cache rather than rerunning the model.\n\nFor example, consider a model that generates local weather forecasts (predictions) once every four hours. After each model run, the system caches all the local weather forecasts. Weather apps retrieve the forecasts from the cache.\n\nOffline inference is also called static inference.\n\nContrast with online inference.\n\nSee Production ML systems: Static versus dynamic inference in Machine Learning Crash Course for more information.",
    "one-hot encoding": "#fundamentals\nRepresenting categorical data as a vector in which:\n\nOne element is set to 1.\nAll other elements are set to 0.\nOne-hot encoding is commonly used to represent strings or identifiers that have a finite set of possible values. For example, suppose a certain categorical feature named Scandinavia has five possible values:\n\n\"Denmark\"\n\"Sweden\"\n\"Norway\"\n\"Finland\"\n\"Iceland\"\nOne-hot encoding could represent each of the five values as follows:\n\ncountry\tVector\n\"Denmark\"\t1\t0\t0\t0\t0\n\"Sweden\"\t0\t1\t0\t0\t0\n\"Norway\"\t0\t0\t1\t0\t0\n\"Finland\"\t0\t0\t0\t1\t0\n\"Iceland\"\t0\t0\t0\t0\t1\nThanks to one-hot encoding, a model can learn different connections based on each of the five countries.\n\nRepresenting a feature as numerical data is an alternative to one-hot encoding. Unfortunately, representing the Scandinavian countries numerically is not a good choice. For example, consider the following numeric representation:\n\n\"Denmark\" is 0\n\"Sweden\" is 1\n\"Norway\" is 2\n\"Finland\" is 3\n\"Iceland\" is 4\nWith numeric encoding, a model would interpret the raw numbers mathematically and would try to train on those numbers. However, Iceland isn't actually twice as much (or half as much) of something as Norway, so the model would come to some strange conclusions.\n\nSee Categorical data: Vocabulary and one-hot encoding in Machine Learning Crash Course for more information.",
    "one-shot learning": "A machine learning approach, often used for object classification, designed to learn effective classification model from a single training example.\n\nSee also few-shot learning and zero-shot learning.",
    "one-shot prompting": "#language#generativeAI\nA prompt that contains one example demonstrating how the large language model should respond. For example, the following prompt contains one example showing a large language model how it should answer a query.\n\nParts of one prompt\tNotes\nWhat is the official currency of the specified country?\tThe question you want the LLM to answer.\nFrance: EUR\tOne example.\nIndia:\tThe actual query.\nCompare and contrast one-shot prompting with the following terms:\n\nzero-shot prompting\nfew-shot prompting",
    "one-vs.-all": "#fundamentals\nGiven a classification problem with N classes, a solution consisting of N separate binary classifiers\u2014one binary classifier for each possible outcome. For example, given a model that classifies examples as animal, vegetable, or mineral, a one-vs.-all solution would provide the following three separate binary classifiers:\n\nanimal versus not animal\nvegetable versus not vegetable\nmineral versus not mineral",
    "online": "#fundamentals\nSynonym for dynamic.",
    "online inference": "#fundamentals\nGenerating predictions on demand. For example, suppose an app passes input to a model and issues a request for a prediction. A system using online inference responds to the request by running the model (and returning the prediction to the app).\n\nContrast with offline inference.\n\nSee Production ML systems: Static versus dynamic inference in Machine Learning Crash Course for more information.",
    "operation (op)": "#TensorFlow\nIn TensorFlow, any procedure that creates, manipulates, or destroys a Tensor. For example, a matrix multiply is an operation that takes two Tensors as input and generates one Tensor as output.",
    "Optax": "A gradient processing and optimization library for JAX. Optax facilitates research by providing building blocks that can be recombined in custom ways to optimize parametric models such as deep neural networks. Other goals include:\n\nProviding readable, well-tested, efficient implementations of core components.\nImproving productivity by making it possible to combine low level ingredients into custom optimizers (or other gradient processing components).\nAccelerating adoption of new ideas by making it easy for anyone to contribute.",
    "optimizer": "A specific implementation of the gradient descent algorithm. Popular optimizers include:\n\nAdaGrad, which stands for ADAptive GRADient descent.\nAdam, which stands for ADAptive with Momentum.",
    "out-group homogeneity bias": "#fairness\nThe tendency to see out-group members as more alike than in-group members when comparing attitudes, values, personality traits, and other characteristics. In-group refers to people you interact with regularly; out-group refers to people you don't interact with regularly. If you create a dataset by asking people to provide attributes about out-groups, those attributes may be less nuanced and more stereotyped than attributes that participants list for people in their in-group.\n\nFor example, Lilliputians might describe the houses of other Lilliputians in great detail, citing small differences in architectural styles, windows, doors, and sizes. However, the same Lilliputians might simply declare that Brobdingnagians all live in identical houses.\n\nOut-group homogeneity bias is a form of group attribution bias.\n\nSee also in-group bias.",
    "outlier detection": "The process of identifying outliers in a training set.\n\nContrast with novelty detection.",
    "outliers": "Values distant from most other values. In machine learning, any of the following are outliers:\n\nInput data whose values are more than roughly 3 standard deviations from the mean.\nWeights with high absolute values.\nPredicted values relatively far away from the actual values.\nFor example, suppose that widget-price is a feature of a certain model. Assume that the mean widget-price is 7 Euros with a standard deviation of 1 Euro. Examples containing a widget-price of 12 Euros or 2 Euros would therefore be considered outliers because each of those prices is five standard deviations from the mean.\n\nOutliers are often caused by typos or other input mistakes. In other cases, outliers aren't mistakes; after all, values five standard deviations away from the mean are rare but hardly impossible.\n\nOutliers often cause problems in model training. Clipping is one way of managing outliers.\n\nSee Working with numerical data in Machine Learning Crash Course for more information.",
    "out-of-bag evaluation (OOB evaluation)": "#df\nA mechanism for evaluating the quality of a decision forest by testing each decision tree against the examples not used during training of that decision tree. For example, in the following diagram, notice that the system trains each decision tree on about two-thirds of the examples and then evaluates against the remaining one-third of the examples.\n\nA decision forest consisting of three decision trees.\n          One decision tree trains on two-thirds of the examples\n          and then uses the remaining one-third for OOB evaluation.\n          A second decision tree trains on a different two-thirds\n          of the examples than the previous decision tree, and then\n          uses a different one-third for OOB evaluation than the\n          previous decision tree.\n\nOut-of-bag evaluation is a computationally efficient and conservative approximation of the cross-validation mechanism. In cross-validation, one model is trained for each cross-validation round (for example, 10 models are trained in a 10-fold cross-validation). With OOB evaluation, a single model is trained. Because bagging withholds some data from each tree during training, OOB evaluation can use that data to approximate cross-validation.\n\nSee Out-of-bag evaluation in the Decision Forests course for more information.",
    "output layer": "#fundamentals\nThe \"final\" layer of a neural network. The output layer contains the prediction.\n\nThe following illustration shows a small deep neural network with an input layer, two hidden layers, and an output layer:\n\nA neural network with one input layer, two hidden layers, and one\n          output layer. The input layer consists of two features. The first\n          hidden layer consists of three neurons and the second hidden layer\n          consists of two neurons. The output layer consists of a single node.",
    "overfitting": "#fundamentals\nCreating a model that matches the training data so closely that the model fails to make correct predictions on new data.\n\nRegularization can reduce overfitting. Training on a large and diverse training set can also reduce overfitting.\n\n Click the icon for additional notes.\nSee Overfitting in Machine Learning Crash Course for more information.",
    "oversampling": "Reusing the examples of a minority class in a class-imbalanced dataset in order to create a more balanced training set.\n\nFor example, consider a binary classification problem in which the ratio of the majority class to the minority class is 5,000:1. If the dataset contains a million examples, then the dataset contains only about 200 examples of the minority class, which might be too few examples for effective training. To overcome this deficiency, you might oversample (reuse) those 200 examples multiple times, possibly yielding sufficient examples for useful training.\n\nYou need to be careful about over overfitting when oversampling.\n\nContrast with undersampling.\n\n\nP",
    "packed data": "An approach for storing data more efficiently.\n\nPacked data stores data either by using a compressed format or in some other way that allows it to be accessed more efficiently. Packed data minimizes the amount of memory and computation required to access it, leading to faster training and more efficient model inference.\n\nPacked data is often used with other techniques, such as data augmentation and regularization, further improving the performance of models.",
    "pandas": "#fundamentals\nA column-oriented data analysis API built on top of numpy. Many machine learning frameworks, including TensorFlow, support pandas data structures as inputs. See the pandas documentation for details.",
    "parameter": "#fundamentals\nThe weights and biases that a model learns during training. For example, in a linear regression model, the parameters consist of the bias (b) and all the weights (w1, w2, and so on) in the following formula:\n\nIn contrast, hyperparameters are the values that you (or a hyperparameter tuning service) supply to the model. For example, learning rate is a hyperparameter.",
    "parameter-efficient tuning": "#language#generativeAI\nA set of techniques to fine-tune a large pre-trained language model (PLM) more efficiently than full fine-tuning. Parameter-efficient tuning typically fine-tunes far fewer parameters than full fine-tuning, yet generally produces a large language model that performs as well (or almost as well) as a large language model built from full fine-tuning.\n\nCompare and contrast parameter-efficient tuning with:\n\ninstruction tuning\nprompt tuning\nParameter-efficient tuning is also known as parameter-efficient fine-tuning.",
    "Parameter Server (PS)": "#TensorFlow\nA job that keeps track of a model's parameters in a distributed setting.",
    "parameter update": "The operation of adjusting a model's parameters during training, typically within a single iteration of gradient descent.",
    "partial derivative": "A derivative in which all but one of the variables is considered a constant. For example, the partial derivative of f(x, y) with respect to x is the derivative of f considered as a function of x alone (that is, keeping y constant). The partial derivative of f with respect to x focuses only on how x is changing and ignores all other variables in the equation.",
    "participation bias": "#fairness\nSynonym for non-response bias. See selection bias.",
    "partitioning strategy": "The algorithm by which variables are divided across parameter servers.",
    "pass at k (pass@k)": "#Metric\nA metric to determine the quality of code (for example, Python) that a large language model generates. More specifically, pass at k tells you the likelihood that at least one generated block of code out of k generated blocks of code will pass all of its unit tests.\n\nLarge language models often struggle to generate good code for complex programming problems. Software engineers adapt to this problem by prompting the large language model to generate multiple (k) solutions for the same problem. Then, software engineers test each of the solutions against unit tests. The calculation of pass at k depends on the outcome of the unit tests:\n\nIf one or more of those solutions pass the unit test, then the LLM Passes that code generation challenge.\nIf none of the solutions pass the unit test, then the LLM Fails that code generation challenge.\nThe formula for pass at k is as follows:\n\n\nIn general, higher values of k produce higher pass at k scores; however, higher values of k require more large language model and unit testing resources.\n\n Click the icon for an example.",
    "Pax": "A programming framework designed for training large-scale neural network models so large that they span multiple TPU accelerator chip slices or pods.\n\nPax is built on Flax, which is built on JAX.\n\nDiagram indicating Pax's position in the software stack.\n          Pax is built on top of JAX. Pax itself consists of three\n          layers. The bottom layer contains TensorStore and Flax.\n          The middle layer contains Optax and Flaxformer. The top\n          layer contains Praxis Modeling Library. Fiddle is built\n          on top of Pax.",
    "perceptron": "A system (either hardware or software) that takes in one or more input values, runs a function on the weighted sum of the inputs, and computes a single output value. In machine learning, the function is typically nonlinear, such as ReLU, sigmoid, or tanh. For example, the following perceptron relies on the sigmoid function to process three input values:\n\nIn the following illustration, the perceptron takes three inputs, each of which is itself modified by a weight before entering the perceptron:\n\nA perceptron that takes in 3 inputs, each multiplied by separate\n          weights. The perceptron outputs a single value.\n\nPerceptrons are the neurons in neural networks.",
    "performance": "#Metric\nOverloaded term with the following meanings:\n\nThe standard meaning within software engineering. Namely: How fast (or efficiently) does this piece of software run?\nThe meaning within machine learning. Here, performance answers the following question: How correct is this model? That is, how good are the model's predictions?",
    "permutation variable importances": "#df#Metric\nA type of variable importance that evaluates the increase in the prediction error of a model after permuting the feature's values. Permutation variable importance is a model-independent metric.",
    "perplexity": "#Metric\nOne measure of how well a model is accomplishing its task. For example, suppose your task is to read the first few letters of a word a user is typing on a phone keyboard, and to offer a list of possible completion words. Perplexity, P, for this task is approximately the number of guesses you need to offer in order for your list to contain the actual word the user is trying to type.\n\nPerplexity is related to cross-entropy as follows:",
    "pipeline": "The infrastructure surrounding a machine learning algorithm. A pipeline includes gathering the data, putting the data into training data files, training one or more models, and exporting the models to production.\n\nSee ML pipelines in the Managing ML Projects course for more information.",
    "pipelining": "#language\nA form of model parallelism in which a model's processing is divided into consecutive stages and each stage is executed on a different device. While a stage is processing one batch, the preceding stage can work on the next batch.\n\nSee also staged training.",
    "pjit": "A JAX function that splits code to run across multiple accelerator chips. The user passes a function to pjit, which returns a function that has the equivalent semantics but is compiled into an XLA computation that runs across multiple devices (such as GPUs or TPU cores).\n\npjit enables users to shard computations without rewriting them by using the SPMD partitioner.\n\nAs of March 2023, pjit has been merged with jit. Refer to Distributed arrays and automatic parallelization for more details.",
    "PLM": "#language#generativeAI\nAbbreviation for pre-trained language model.",
    "pmap": "A JAX function that executes copies of an input function on multiple underlying hardware devices (CPUs, GPUs, or TPUs), with different input values. pmap relies on SPMD.",
    "policy": "#rl\nIn reinforcement learning, an agent's probabilistic mapping from states to actions.",
    "pooling": "#image\nReducing a matrix (or matrixes) created by an earlier convolutional layer to a smaller matrix. Pooling usually involves taking either the maximum or average value across the pooled area. For example, suppose we have the following 3x3 matrix:\n\nThe 3x3 matrix [[5,3,1], [8,2,5], [9,4,3]].\n\nA pooling operation, just like a convolutional operation, divides that matrix into slices and then slides that convolutional operation by strides. For example, suppose the pooling operation divides the convolutional matrix into 2x2 slices with a 1x1 stride. As the following diagram illustrates, four pooling operations take place. Imagine that each pooling operation picks the maximum value of the four in that slice:\n\nThe input matrix is 3x3 with the values: [[5,3,1], [8,2,5], [9,4,3]].\n          The top-left 2x2 submatrix of the input matrix is [[5,3], [8,2]], so\n          the top-left pooling operation yields the value 8 (which is the\n          maximum of 5, 3, 8, and 2). The top-right 2x2 submatrix of the input\n          matrix is [[3,1], [2,5]], so the top-right pooling operation yields\n          the value 5. The bottom-left 2x2 submatrix of the input matrix is\n          [[8,2], [9,4]], so the bottom-left pooling operation yields the value\n          9. The bottom-right 2x2 submatrix of the input matrix is\n          [[2,5], [4,3]], so the bottom-right pooling operation yields the value\n          5. In summary, the pooling operation yields the 2x2 matrix\n          [[8,5], [9,5]].\n\nPooling helps enforce translational invariance in the input matrix.\n\nPooling for vision applications is known more formally as spatial pooling. Time-series applications usually refer to pooling as temporal pooling. Less formally, pooling is often called subsampling or downsampling.\n\nSee Introducing Convolutional Neural Networks in the ML Practicum: Image Classification course.",
    "positional encoding": "#language\nA technique to add information about the position of a token in a sequence to the token's embedding. Transformer models use positional encoding to better understand the relationship between different parts of the sequence.\n\nA common implementation of positional encoding uses a sinusoidal function. (Specifically, the frequency and amplitude of the sinusoidal function are determined by the position of the token in the sequence.) This technique enables a Transformer model to learn to attend to different parts of the sequence based on their position.",
    "positive class": "#fundamentals#Metric\nThe class you are testing for.\n\nFor example, the positive class in a cancer model might be \"tumor.\" The positive class in an email classification model might be \"spam.\"\n\nContrast with negative class.\n\n Click the icon for additional notes.",
    "post-processing": "#fairness#fundamentals\nAdjusting the output of a model after the model has been run. Post-processing can be used to enforce fairness constraints without modifying models themselves.\n\nFor example, one might apply post-processing to a binary classifier by setting a classification threshold such that equality of opportunity is maintained for some attribute by checking that the true positive rate is the same for all values of that attribute.",
    "post-trained model": "#language#image#generativeAI\nLoosely-defined term that typically refers to a pre-trained model that has gone through some post-processing, such as one or more of the following:\n\nDistillation\nFine-tuning\nInstruction tuning",
    "PR AUC (area under the PR curve)": "#Metric\nArea under the interpolated precision-recall curve, obtained by plotting (recall, precision) points for different values of the classification threshold.",
    "Praxis": "A core, high-performance ML library of Pax. Praxis is often called the \"Layer library\".\n\nPraxis contains not just the definitions for the Layer class, but most of its supporting components as well, including:\n\ndata inputs\nconfiguration libraries (HParam and Fiddle)\noptimizers\nPraxis provides the definitions for the Model class.",
    "precision": "#Metric\nA metric for classification models that answers the following question:\n\nWhen the model predicted the positive class, what percentage of the predictions were correct?\n\nHere is the formula:\n\nwhere:\n\ntrue positive means the model correctly predicted the positive class.\nfalse positive means the model mistakenly predicted the positive class.\nFor example, suppose a model made 200 positive predictions. Of these 200 positive predictions:\n\n150 were true positives.\n50 were false positives.\nIn this case:\n\nContrast with accuracy and recall.\n\nSee Classification: Accuracy, recall, precision and related metrics in Machine Learning Crash Course for more information.",
    "precision at k (precision@k)": "#language#Metric\nA metric for evaluating a ranked (ordered) list of items. Precision at k identifies the fraction of the first k items in that list that are \"relevant.\" That is:\n\n\nThe value of k must be less than or equal to the length of the returned list. Note that the length of the returned list is not part of the calculation.\n\nRelevance is often subjective; even expert human evaluators often disagree on which items are relevant.\n\nCompare with:\n\naverage precision at k\nmean average precision at k\n Click the icon to see an example.",
    "precision-recall curve": "#Metric\nA curve of precision versus recall at different classification thresholds.",
    "prediction": "#fundamentals\nA model's output. For example:\n\nThe prediction of a binary classification model is either the positive class or the negative class.\nThe prediction of a multi-class classification model is one class.\nThe prediction of a linear regression model is a number.",
    "prediction bias": "#Metric\nA value indicating how far apart the average of predictions is from the average of labels in the dataset.\n\nNot to be confused with the bias term in machine learning models or with bias in ethics and fairness.",
    "predictive ML": "Any standard (\"classic\") machine learning system.\n\nThe term predictive ML doesn't have a formal definition. Rather, the term distinguishes a category of ML systems not based on generative AI.",
    "predictive parity": "#fairness#Metric\nA fairness metric that checks whether, for a given classifier, the precision rates are equivalent for subgroups under consideration.\n\nFor example, a model that predicts college acceptance would satisfy predictive parity for nationality if its precision rate is the same for Lilliputians and Brobdingnagians.\n\nPredictive parity is sometime also called predictive rate parity.\n\nSee \"Fairness Definitions Explained\" (section 3.2.1) for a more detailed discussion of predictive parity.",
    "predictive rate parity": "#fairness#Metric\nAnother name for predictive parity.",
    "preprocessing": "#fairnessProcessing data before it's used to train a model. Preprocessing could be as simple as removing words from an English text corpus that don't occur in the English dictionary, or could be as complex as re-expressing data points in a way that eliminates as many attributes that are correlated with sensitive attributes as possible. Preprocessing can help satisfy fairness constraints.",
    "pre-trained model": "#language#image#generativeAI\nTypically, a model that has already been trained. The term could also mean a previously trained embedding vector.\n\nThe term pre-trained language model usually refers to an already trained large language model.",
    "pre-training": "#language#image#generativeAI\nThe initial training of a model on a large dataset. Some pre-trained models are clumsy giants and must typically be refined through additional training. For example, ML experts might pre-train a large language model on a vast text dataset, such as all the English pages in Wikipedia. Following pre-training, the resulting model might be further refined through any of the following techniques:\n\ndistillation\nfine-tuning\ninstruction tuning\nparameter-efficient tuning\nprompt-tuning",
    "prior belief": "What you believe about the data before you begin training on it. For example, L2 regularization relies on a prior belief that weights should be small and normally distributed around zero.",
    "probabilistic regression model": "A regression model that uses not only the weights for each feature, but also the uncertainty of those weights. A probabilistic regression model generates a prediction and the uncertainty of that prediction. For example, a probabilistic regression model might yield a prediction of 325 with a standard deviation of 12. For more information about probabilistic regression models, see this Colab on tensorflow.org.",
    "probability density function": "#Metric\nA function that identifies the frequency of data samples having exactly a particular value. When a dataset's values are continuous floating-point numbers, exact matches rarely occur. However, integrating a probability density function from value x to value y yields the expected frequency of data samples between x and y.\n\nFor example, consider a normal distribution having a mean of 200 and a standard deviation of 30. To determine the expected frequency of data samples falling within the range 211.4 to 218.7, you can integrate the probability density function for a normal distribution from 211.4 to 218.7.",
    "prompt": "#language#generativeAI\nAny text entered as input to a large language model to condition the model to behave in a certain way. Prompts can be as short as a phrase or arbitrarily long (for example, the entire text of a novel). Prompts fall into multiple categories, including those shown in the following table:\n\nPrompt category\tExample\tNotes\nQuestion\tHow fast can a pigeon fly?\nInstruction\tWrite a funny poem about arbitrage.\tA prompt that asks the large language model to do something.\nExample\tTranslate Markdown code to HTML. For example:\nMarkdown: * list item\nHTML: <ul> <li>list item</li> </ul>\tThe first sentence in this example prompt is an instruction. The remainder of the prompt is the example.\nRole\tExplain why gradient descent is used in machine learning training to a PhD in Physics.\tThe first part of the sentence is an instruction; the phrase \"to a PhD in Physics\" is the role portion.\nPartial input for the model to complete\tThe Prime Minister of the United Kingdom lives at\tA partial input prompt can either end abruptly (as this example does) or end with an underscore.\nA generative AI model can respond to a prompt with text, code, images, embeddings, videos\u2026almost anything.",
    "prompt-based learning": "#language#generativeAI\nA capability of certain models that enables them to adapt their behavior in response to arbitrary text input (prompts). In a typical prompt-based learning paradigm, a large language model responds to a prompt by generating text. For example, suppose a user enters the following prompt:\n\nSummarize Newton's Third Law of Motion.\n\nA model capable of prompt-based learning isn't specifically trained to answer the previous prompt. Rather, the model \"knows\" a lot of facts about physics, a lot about general language rules, and a lot about what constitutes generally useful answers. That knowledge is sufficient to provide a (hopefully) useful answer. Additional human feedback (\"That answer was too complicated.\" or \"What's a reaction?\") enables some prompt-based learning systems to gradually improve the usefulness of their answers.",
    "prompt design": "#language#generativeAI\nSynonym for prompt engineering.",
    "prompt engineering": "#language#generativeAI\nThe art of creating prompts that elicit the desired responses from a large language model. Humans perform prompt engineering. Writing well-structured prompts is an essential part of ensuring useful responses from a large language model. Prompt engineering depends on many factors, including:\n\nThe dataset used to pre-train and possibly fine-tune the large language model.\nThe temperature and other decoding parameters that the model uses to generate responses.\nPrompt design is a synonym for prompt engineering.\n\nSee Introduction to prompt design for more details on writing helpful prompts.",
    "prompt tuning": "#language#generativeAI\nA parameter efficient tuning mechanism that learns a \"prefix\" that the system prepends to the actual prompt.\n\nOne variation of prompt tuning\u2014sometimes called prefix tuning\u2014is to prepend the prefix at every layer. In contrast, most prompt tuning only adds a prefix to the input layer.\n\n Click the icon to learn more about prefixes.",
    "proxy (sensitive attributes)": "#fairnessAn attribute used as a stand-in for a sensitive attribute. For example, an individual's postal code might be used as a proxy for their income, race, or ethnicity.",
    "proxy labels": "#fundamentals\nData used to approximate labels not directly available in a dataset.\n\nFor example, suppose you must train a model to predict employee stress level. Your dataset contains a lot of predictive features but doesn't contain a label named stress level. Undaunted, you pick \"workplace accidents\" as a proxy label for stress level. After all, employees under high stress get into more accidents than calm employees. Or do they? Maybe workplace accidents actually rise and fall for multiple reasons.\n\nAs a second example, suppose you want is it raining? to be a Boolean label for your dataset, but your dataset doesn't contain rain data. If photographs are available, you might establish pictures of people carrying umbrellas as a proxy label for is it raining? Is that a good proxy label? Possibly, but people in some cultures may be more likely to carry umbrellas to protect against sun than the rain.\n\nProxy labels are often imperfect. When possible, choose actual labels over proxy labels. That said, when an actual label is absent, pick the proxy label very carefully, choosing the least horrible proxy label candidate.\n\nSee Datasets: Labels in Machine Learning Crash Course for more information.",
    "pure function": "A function whose outputs are based only on its inputs, and that has no side effects. Specifically, a pure function doesn't use or change any global state, such as the contents of a file or the value of a variable outside the function.\n\nPure functions can be used to create thread-safe code, which is beneficial when sharding model code across multiple accelerator chips.\n\nJAX's function transformation methods require that the input functions are pure functions.\n\n\nQ",
    "Q-function": "#rl\nIn reinforcement learning, the function that predicts the expected return from taking an action in a state and then following a given policy.\n\nQ-function is also known as state-action value function.",
    "Q-learning": "#rl\nIn reinforcement learning, an algorithm that allows an agent to learn the optimal Q-function of a Markov decision process by applying the Bellman equation. The Markov decision process models an environment.",
    "quantile": "Each bucket in quantile bucketing.",
    "quantile bucketing": "Distributing a feature's values into buckets so that each bucket contains the same (or almost the same) number of examples. For example, the following figure divides 44 points into 4 buckets, each of which contains 11 points. In order for each bucket in the figure to contain the same number of points, some buckets span a different width of x-values.\n\n44 data points divided into 4 buckets of 11 points each.\n          Although each bucket contains the same number of data points,\n          some buckets contain a wider range of feature values than other\n          buckets.\n\nSee Numerical data: Binning in Machine Learning Crash Course for more information.",
    "quantization": "Overloaded term that could be used in any of the following ways:\n\nImplementing quantile bucketing on a particular feature.\nTransforming data into zeroes and ones for quicker storing, training, and inferring. As Boolean data is more robust to noise and errors than other formats, quantization can improve model correctness. Quantization techniques include rounding, truncating, and binning.\nReducing the number of bits used to store a model's parameters. For example, suppose a model's parameters are stored as 32-bit floating-point numbers. Quantization converts those parameters from 32 bits down to 4, 8, or 16 bits. Quantization reduces the following:\n\nCompute, memory, disk, and network usage\nTime to infer a predication\nPower consumption\nHowever, quantization sometimes decreases the correctness of a model's predictions.",
    "queue": "#TensorFlow\nA TensorFlow Operation that implements a queue data structure. Typically used in I/O.\n\n\nR",
    "RAG": "#fundamentals\nAbbreviation for retrieval-augmented generation.",
    "random forest": "#df\nAn ensemble of decision trees in which each decision tree is trained with a specific random noise, such as bagging.\n\nRandom forests are a type of decision forest.\n\nSee Random Forest in the Decision Forests course for more information.",
    "random policy": "#rl\nIn reinforcement learning, a policy that chooses an action at random.",
    "rank (ordinality)": "The ordinal position of a class in a machine learning problem that categorizes classes from highest to lowest. For example, a behavior ranking system could rank a dog's rewards from highest (a steak) to lowest (wilted kale).",
    "rank (Tensor)": "#TensorFlow\nThe number of dimensions in a Tensor. For example, a scalar has rank 0, a vector has rank 1, and a matrix has rank 2.\n\nNot to be confused with rank (ordinality).",
    "ranking": "A type of supervised learning whose objective is to order a list of items.",
    "rater": "#fundamentals\nA human who provides labels for examples. \"Annotator\" is another name for rater.\n\nSee Categorical data: Common issues in Machine Learning Crash Course for more information.",
    "recall": "#Metric\nA metric for classification models that answers the following question:\n\nWhen ground truth was the positive class, what percentage of predictions did the model correctly identify as the positive class?\n\nHere is the formula:\n\n\nwhere:\n\ntrue positive means the model correctly predicted the positive class.\nfalse negative means that the model mistakenly predicted the negative class.\nFor instance, suppose your model made 200 predictions on examples for which ground truth was the positive class. Of these 200 predictions:\n\n180 were true positives.\n20 were false negatives.\nIn this case:\n\n\n Click the icon for notes about class-imbalanced datasets.\nSee Classification: Accuracy, recall, precision and related metrics for more information.",
    "recall at k (recall@k)": "#language#Metric\nA metric for evaluating systems that output a ranked (ordered) list of items. Recall at k identifies the fraction of relevant items in the first k items in that list out of the total number of relevant items returned.\n\n\nContrast with precision at k.\n\n Click the icon to see an example.",
    "recommendation system": "#recsystems\nA system that selects for each user a relatively small set of desirable items from a large corpus. For example, a video recommendation system might recommend two videos from a corpus of 100,000 videos, selecting Casablanca and The Philadelphia Story for one user, and Wonder Woman and Black Panther for another. A video recommendation system might base its recommendations on factors such as:\n\nMovies that similar users have rated or watched.\nGenre, directors, actors, target demographic...\nSee the Recommendation Systems course for more information.",
    "Rectified Linear Unit (ReLU)": "#fundamentals\nAn activation function with the following behavior:\n\nIf input is negative or zero, then the output is 0.\nIf input is positive, then the output is equal to the input.\nFor example:\n\nIf the input is -3, then the output is 0.\nIf the input is +3, then the output is 3.0.\nHere is a plot of ReLU:\n\nA cartesian plot of two lines. The first line has a constant\n          y value of 0, running along the x-axis from -infinity,0 to 0,-0.\n          The second line starts at 0,0. This line has a slope of +1, so\n          it runs from 0,0 to +infinity,+infinity.\n\nReLU is a very popular activation function. Despite its simple behavior, ReLU still enables a neural network to learn nonlinear relationships between features and the label.",
    "recurrent neural network": "#seq\nA neural network that is intentionally run multiple times, where parts of each run feed into the next run. Specifically, hidden layers from the previous run provide part of the input to the same hidden layer in the next run. Recurrent neural networks are particularly useful for evaluating sequences, so that the hidden layers can learn from previous runs of the neural network on earlier parts of the sequence.\n\nFor example, the following figure shows a recurrent neural network that runs four times. Notice that the values learned in the hidden layers from the first run become part of the input to the same hidden layers in the second run. Similarly, the values learned in the hidden layer on the second run become part of the input to the same hidden layer in the third run. In this way, the recurrent neural network gradually trains and predicts the meaning of the entire sequence rather than just the meaning of individual words.\n\nAn RNN that runs four times to process four input words.",
    "reference text": "#language#generativeAI\nAn expert's response to a prompt. For example, given the following prompt:\n\nTranslate the question \"What is your name?\" from English to French.\n\nAn expert's response might be:\n\nComment vous appelez-vous?\n\nVarious metrics (such as ROUGE) measure the degree to which the reference text matches an ML model's generated text.\n\nNote: The expert is typically a human but could be an ML model.",
    "regression model": "#fundamentals\nInformally, a model that generates a numerical prediction. (In contrast, a classification model generates a class prediction.) For example, the following are all regression models:\n\nA model that predicts a certain house's value in Euros, such as 423,000.\nA model that predicts a certain tree's life expectancy in years, such as 23.2.\nA model that predicts the amount of rain in inches that will fall in a certain city over the next six hours, such as 0.18.\nTwo common types of regression models are:\n\nLinear regression, which finds the line that best fits label values to features.\nLogistic regression, which generates a probability between 0.0 and 1.0 that a system typically then maps to a class prediction.\nNot every model that outputs numerical predictions is a regression model. In some cases, a numeric prediction is really just a classification model that happens to have numeric class names. For example, a model that predicts a numeric postal code is a classification model, not a regression model.",
    "regularization": "#fundamentals\nAny mechanism that reduces overfitting. Popular types of regularization include:\n\nL1 regularization\nL2 regularization\ndropout regularization\nearly stopping (this is not a formal regularization method, but can effectively limit overfitting)\nRegularization can also be defined as the penalty on a model's complexity.\n\n Click the icon for additional notes.\nSee Overfitting: Model complexity in Machine Learning Crash Course for more information.",
    "regularization rate": "#fundamentals\nA number that specifies the relative importance of regularization during training. Raising the regularization rate reduces overfitting but may reduce the model's predictive power. Conversely, reducing or omitting the regularization rate increases overfitting.\n\n Click the icon to see the math.\nSee Overfitting: L2 regularization in Machine Learning Crash Course for more information.",
    "reinforcement learning (RL)": "#rl\nA family of algorithms that learn an optimal policy, whose goal is to maximize return when interacting with an environment. For example, the ultimate reward of most games is victory. Reinforcement learning systems can become expert at playing complex games by evaluating sequences of previous game moves that ultimately led to wins and sequences that ultimately led to losses.",
    "Reinforcement Learning from Human Feedback (RLHF)": "#generativeAI#rl\nUsing feedback from human raters to improve the quality of a model's responses. For example, an RLHF mechanism can ask users to rate the quality of a model's response with a \ud83d\udc4d or \ud83d\udc4e emoji. The system can then adjust its future responses based on that feedback.",
    "ReLU": "#fundamentals\nAbbreviation for Rectified Linear Unit.",
    "replay buffer": "#rl\nIn DQN-like algorithms, the memory used by the agent to store state transitions for use in experience replay.",
    "replica": "A copy of the training set or model, typically on another machine. For example, a system could use the following strategy for implementing data parallelism:\n\nPlace replicas of an existing model on multiple machines.\nSend different subsets of the training set to each replica.\nAggregate the parameter updates.",
    "reporting bias": "#fairness\nThe fact that the frequency with which people write about actions, outcomes, or properties is not a reflection of their real-world frequencies or the degree to which a property is characteristic of a class of individuals. Reporting bias can influence the composition of data that machine learning systems learn from.\n\nFor example, in books, the word laughed is more prevalent than breathed. A machine learning model that estimates the relative frequency of laughing and breathing from a book corpus would probably determine that laughing is more common than breathing.\n\nSee Fairness: Types of bias in Machine Learning Crash Course for more information.",
    "representation": "The process of mapping data to useful features.",
    "re-ranking": "#recsystems\nThe final stage of a recommendation system, during which scored items may be re-graded according to some other (typically, non-ML) algorithm. Re-ranking evaluates the list of items generated by the scoring phase, taking actions such as:\n\nEliminating items that the user has already purchased.\nBoosting the score of fresher items.\nSee Re-ranking in the Recommendation Systems course for more information.",
    "retrieval-augmented generation (RAG)": "#fundamentals\nA technique for improving the quality of large language model (LLM) output by grounding it with sources of knowledge retrieved after the model was trained. RAG improves the accuracy of LLM responses by providing the trained LLM with access to information retrieved from trusted knowledge bases or documents.\n\nCommon motivations to use retrieval-augmented generation include:\n\nIncreasing the factual accuracy of a model's generated responses.\nGiving the model access to knowledge it was not trained on.\nChanging the knowledge that the model uses.\nEnabling the model to cite sources.\nFor example, suppose that a chemistry app uses the PaLM API to generate summaries related to user queries. When the app's backend receives a query, the backend:\n\nSearches for (\"retrieves\") data that's relevant to the user's query.\nAppends (\"augments\") the relevant chemistry data to the user's query.\nInstructs the LLM to create a summary based on the appended data.",
    "return": "#rl\nIn reinforcement learning, given a certain policy and a certain state, the return is the sum of all rewards that the agent expects to receive when following the policy from the state to the end of the episode. The agent accounts for the delayed nature of expected rewards by discounting rewards according to the state transitions required to obtain the reward.\n\nTherefore, if the discount factor is \n, and \n denote the rewards until the end of the episode, then the return calculation is as follows:",
    "reward": "#rl\nIn reinforcement learning, the numerical result of taking an action in a state, as defined by the environment.",
    "ridge regularization": "Synonym for L2 regularization. The term ridge regularization is more frequently used in pure statistics contexts, whereas L2 regularization is used more often in machine learning.",
    "RNN": "#seq\nAbbreviation for recurrent neural networks.",
    "ROC (receiver operating characteristic) Curve": "#fundamentals#Metric\nA graph of true positive rate versus false positive rate for different classification thresholds in binary classification.\n\nThe shape of an ROC curve suggests a binary classification model's ability to separate positive classes from negative classes. Suppose, for example, that a binary classification model perfectly separates all the negative classes from all the positive classes:\n\nA number line with 8 positive examples on the right side and\n          7 negative examples on the left.\n\nThe ROC curve for the preceding model looks as follows:\n\nAn ROC curve. The x-axis is False Positive Rate and the y-axis\n          is True Positive Rate. The curve has an inverted L shape. The curve\n          starts at (0.0,0.0) and goes straight up to (0.0,1.0). Then the curve\n          goes from (0.0,1.0) to (1.0,1.0).\n\nIn contrast, the following illustration graphs the raw logistic regression values for a terrible model that can't separate negative classes from positive classes at all:\n\nA number line with positive examples and negative classes\n          completely intermixed.\n\nThe ROC curve for this model looks as follows:\n\nAn ROC curve, which is actually a straight line from (0.0,0.0)\n          to (1.0,1.0).\n\nMeanwhile, back in the real world, most binary classification models separate positive and negative classes to some degree, but usually not perfectly. So, a typical ROC curve falls somewhere between the two extremes:\n\nAn ROC curve. The x-axis is False Positive Rate and the y-axis\n          is True Positive Rate. The ROC curve approximates a shaky arc\n          traversing the compass points from West to North.\n\nThe point on an ROC curve closest to (0.0,1.0) theoretically identifies the ideal classification threshold. However, several other real-world issues influence the selection of the ideal classification threshold. For example, perhaps false negatives cause far more pain than false positives.\n\nA numerical metric called AUC summarizes the ROC curve into a single floating-point value.",
    "role prompting": "#language#generativeAI\nAn optional part of a prompt that identifies a target audience for a generative AI model's response. Without a role prompt, a large language model provides an answer that may or may not be useful for the person asking the questions. With a role prompt, a large language model can answer in a way that's more appropriate and more helpful for a specific target audience. For example, the role prompt portion of the following prompts are in boldface:\n\nSummarize this document for a PhD in economics.\nDescribe how tides work for a ten-year old.\nExplain the 2008 financial crisis. Speak as you might to a young child, or a golden retriever.",
    "root": "#df\nThe starting node (the first condition) in a decision tree. By convention, diagrams put the root at the top of the decision tree. For example:\n\nA decision tree with two conditions and three leaves. The\n          starting condition (x > 2) is the root.",
    "root directory": "#TensorFlow\nThe directory you specify for hosting subdirectories of the TensorFlow checkpoint and events files of multiple models.",
    "Root Mean Squared Error (RMSE)": "#fundamentals#Metric\nThe square root of the Mean Squared Error.",
    "rotational invariance": "#image\nIn an image classification problem, an algorithm's ability to successfully classify images even when the orientation of the image changes. For example, the algorithm can still identify a tennis racket whether it is pointing up, sideways, or down. Note that rotational invariance is not always desirable; for example, an upside-down 9 shouldn't be classified as a 9.\n\nSee also translational invariance and size invariance.",
    "ROUGE (Recall-Oriented Understudy for Gisting Evaluation)": "#language#Metric\nA family of metrics that evaluate automatic summarization and machine translation models. ROUGE metrics determine the degree to which a reference text overlaps an ML model's generated text. Each member of the ROUGE family measures overlap in a different way. Higher ROUGE scores indicate more similarity between the reference text and generated text than lower ROUGE scores.\n\nEach ROUGE family member typically generates the following metrics:\n\nPrecision\nRecall\nF1\nNote: ROUGE uses precision and recall somewhat differently than traditional precision and recall.\nFor details and examples, see:\n\nROUGE-L\nROUGE-N\nROUGE-S\nNote: BLEU and BLEURT optimize for precision while ROUGE optimizes for recall. Consequently, BLEU and BLEURT are better metrics for evaluating machine translation (since the focus is precision) while ROUGE is a better metric for summarization (since the focus is recall).",
    "ROUGE-L": "#language#Metric\nA member of the ROUGE family focused on the length of the longest common subsequence in the reference text and generated text. The following formulas calculate recall and precision for ROUGE-L:\n\nYou can then use F1 to roll up ROUGE-L recall and ROUGE-L precision into a single metric:\n\n Click the icon for an example calculation of ROUGE-L.\nROUGE-L ignores any newlines in the reference text and generated text, so the longest common subsequence could cross multiple sentences. When the reference text and generated text involve multiple sentences, a variation of ROUGE-L called ROUGE-Lsum is generally a better metric. ROUGE-Lsum determines the longest common subsequence for each sentence in a passage and then calculates the mean of those longest common subsequences.\n\n Click the icon for an example calculation of ROUGE-Lsum.",
    "ROUGE-N": "#language#Metric\nA set of metrics within the ROUGE family that compares the shared N-grams of a certain size in the reference text and generated text. For example:\n\nROUGE-1 measures the number of shared tokens in the reference text and generated text.\nROUGE-2 measures the number of shared bigrams (2-grams) in the reference text and generated text.\nROUGE-3 measures the number of shared trigrams (3-grams) in the reference text and generated text.\nYou can use the following formulas to calculate ROUGE-N recall and ROUGE-N precision for any member of the ROUGE-N family:\n\nYou can then use F1 to roll up ROUGE-N recall and ROUGE-N precision into a single metric:\n\n Click the icon for an example.",
    "ROUGE-S": "#language#Metric\nA forgiving form of ROUGE-N that enables skip-gram matching. That is, ROUGE-N only counts N-grams that match exactly, but ROUGE-S also counts N-grams separated by one or more words. For example, consider the following:\n\nreference text: White clouds\ngenerated text: White billowing clouds\nWhen calculating ROUGE-N, the 2-gram, White clouds doesn't match White billowing clouds. However, when calculating ROUGE-S, White clouds does match White billowing clouds.",
    "R-squared": "#Metric\nA regression metric indicating how much variation in a label is due to an individual feature or to a feature set. R-squared is a value between 0 and 1, which you can interpret as follows:\n\nAn R-squared of 0 means that none of a label's variation is due to the feature set.\nAn R-squared of 1 means that all of a label's variation is due to the feature set.\nAn R-squared between 0 and 1 indicates the extent to which the label's variation can be predicted from a particular feature or the feature set. For example, an R-squared of 0.10 means that 10 percent of the variance in the label is due to the feature set, an R-squared of 0.20 means that 20 percent is due to the feature set, and so on.\nR-squared is the square of the Pearson correlation coefficient between the values that a model predicted and ground truth.\n\n\nS",
    "sampling bias": "#fairness\nSee selection bias.",
    "sampling with replacement": "#df\nA method of picking items from a set of candidate items in which the same item can be picked multiple times. The phrase \"with replacement\" means that after each selection, the selected item is returned to the pool of candidate items. The inverse method, sampling without replacement, means that a candidate item can only be picked once.\n\nFor example, consider the following fruit set:\n\nfruit = {kiwi, apple, pear, fig, cherry, lime, mango}\nSuppose that the system randomly picks fig as the first item. If using sampling with replacement, then the system picks the second item from the following set:\n\nfruit = {kiwi, apple, pear, fig, cherry, lime, mango}\nYes, that's the same set as before, so the system could potentially pick fig again.\n\nIf using sampling without replacement, once picked, a sample can't be picked again. For example, if the system randomly picks fig as the first sample, then fig can't be picked again. Therefore, the system picks the second sample from the following (reduced) set:\n\nfruit = {kiwi, apple, pear, cherry, lime, mango}\n Click the icon for additional notes.",
    "SavedModel": "#TensorFlow\nThe recommended format for saving and recovering TensorFlow models. SavedModel is a language-neutral, recoverable serialization format, which enables higher-level systems and tools to produce, consume, and transform TensorFlow models.\n\nSee the Saving and Restoring section of the TensorFlow Programmer's Guide for complete details.",
    "Saver": "#TensorFlow\nA TensorFlow object responsible for saving model checkpoints.",
    "scalar": "A single number or a single string that can be represented as a tensor of rank 0. For example, the following lines of code each create one scalar in TensorFlow:\n\nbreed = tf.Variable(\"poodle\", tf.string)\ntemperature = tf.Variable(27, tf.int16)\nprecision = tf.Variable(0.982375101275, tf.float64)",
    "scaling": "Any mathematical transform or technique that shifts the range of a label, a feature value, or both. Some forms of scaling are very useful for transformations like normalization.\n\nCommon forms of scaling useful in Machine Learning include:\n\nlinear scaling, which typically uses a combination of subtraction and division to replace the original value with a number between -1 and +1 or between 0 and 1.\nlogarithmic scaling, which replaces the original value with its logarithm.\nZ-score normalization, which replaces the original value with a floating-point value representing the number of standard deviations from that feature's mean.",
    "scikit-learn": "A popular open-source machine learning platform. See scikit-learn.org.",
    "scoring": "#recsystems#Metric\nThe part of a recommendation system that provides a value or ranking for each item produced by the candidate generation phase.",
    "selection bias": "#fairness\nErrors in conclusions drawn from sampled data due to a selection process that generates systematic differences between samples observed in the data and those not observed. The following forms of selection bias exist:\n\ncoverage bias: The population represented in the dataset doesn't match the population that the machine learning model is making predictions about.\nsampling bias: Data is not collected randomly from the target group.\nnon-response bias (also called participation bias): Users from certain groups opt-out of surveys at different rates than users from other groups.\nFor example, suppose you are creating a machine learning model that predicts people's enjoyment of a movie. To collect training data, you hand out a survey to everyone in the front row of a theater showing the movie. Offhand, this may sound like a reasonable way to gather a dataset; however, this form of data collection may introduce the following forms of selection bias:\n\ncoverage bias: By sampling from a population who chose to see the movie, your model's predictions may not generalize to people who did not already express that level of interest in the movie.\nsampling bias: Rather than randomly sampling from the intended population (all the people at the movie), you sampled only the people in the front row. It is possible that the people sitting in the front row were more interested in the movie than those in other rows.\nnon-response bias: In general, people with strong opinions tend to respond to optional surveys more frequently than people with mild opinions. Since the movie survey is optional, the responses are more likely to form a bimodal distribution than a normal (bell-shaped) distribution.",
    "self-attention (also called self-attention layer)": "#language\nA neural network layer that transforms a sequence of embeddings (for example, token embeddings) into another sequence of embeddings. Each embedding in the output sequence is constructed by integrating information from the elements of the input sequence through an attention mechanism.\n\nThe self part of self-attention refers to the sequence attending to itself rather than to some other context. Self-attention is one of the main building blocks for Transformers and uses dictionary lookup terminology, such as \"query\", \"key\", and \"value\".\n\nA self-attention layer starts with a sequence of input representations, one for each word. The input representation for a word can be a simple embedding. For each word in an input sequence, the network scores the relevance of the word to every element in the whole sequence of words. The relevance scores determine how much the word's final representation incorporates the representations of other words.\n\nFor example, consider the following sentence:\n\nThe animal didn't cross the street because it was too tired.\n\nThe following illustration (from Transformer: A Novel Neural Network Architecture for Language Understanding) shows a self-attention layer's attention pattern for the pronoun it, with the darkness of each line indicating how much each word contributes to the representation:\n\nThe following sentence appears twice: The animal didn't cross the\n          street because it was too tired. Lines connect the pronoun it in\n          one sentence to five tokens (The, animal, street, it, and\n          the period) in the other sentence. The line between the pronoun it\n          and the word animal is strongest.\n\nThe self-attention layer highlights words that are relevant to \"it\". In this case, the attention layer has learned to highlight words that it might refer to, assigning the highest weight to animal.\n\nFor a sequence of n tokens, self-attention transforms a sequence of embeddings n separate times, once at each position in the sequence.\n\nRefer also to attention and multi-head self-attention.",
    "self-supervised learning": "A family of techniques for converting an unsupervised machine learning problem into a supervised machine learning problem by creating surrogate labels from unlabeled examples.\n\nSome Transformer-based models such as BERT use self-supervised learning.\n\nSelf-supervised training is a semi-supervised learning approach.",
    "self-training": "A variant of self-supervised learning that is particularly useful when all of the following conditions are true:\n\nThe ratio of unlabeled examples to labeled examples in the dataset is high.\nThis is a classification problem.\nSelf-training works by iterating over the following two steps until the model stops improving:\n\nUse supervised machine learning to train a model on the labeled examples.\nUse the model created in Step 1 to generate predictions (labels) on the unlabeled examples, moving those in which there is high confidence into the labeled examples with the predicted label.\nNotice that each iteration of Step 2 adds more labeled examples for Step 1 to train on.",
    "semi-supervised learning": "Training a model on data where some of the training examples have labels but others don't. One technique for semi-supervised learning is to infer labels for the unlabeled examples, and then to train on the inferred labels to create a new model. Semi-supervised learning can be useful if labels are expensive to obtain but unlabeled examples are plentiful.\n\nSelf-training is one technique for semi-supervised learning.",
    "sensitive attribute": "#fairnessA human attribute that may be given special consideration for legal, ethical, social, or personal reasons.",
    "sentiment analysis": "#language\nUsing statistical or machine learning algorithms to determine a group's overall attitude\u2014positive or negative\u2014toward a service, product, organization, or topic. For example, using natural language understanding, an algorithm could perform sentiment analysis on the textual feedback from a university course to determine the degree to which students generally liked or disliked the course.\n\nSee the Text classification guide for more information.",
    "sequence model": "#seq\nA model whose inputs have a sequential dependence. For example, predicting the next video watched from a sequence of previously watched videos.",
    "sequence-to-sequence task": "#language\nA task that converts an input sequence of tokens to an output sequence of tokens. For example, two popular kinds of sequence-to-sequence tasks are:\n\nTranslators:\nSample input sequence: \"I love you.\"\nSample output sequence: \"Je t'aime.\"\nQuestion answering:\nSample input sequence: \"Do I need my car in New York City?\"\nSample output sequence: \"No. Keep your car at home.\"\n\nserving\nThe process of making a trained model available to provide predictions through online inference or offline inference.",
    "shape (Tensor)": "The number of elements in each dimension of a tensor. The shape is represented as a list of integers. For example, the following two-dimensional tensor has a shape of [3,4]:\n\n[[5, 7, 6, 4],\n [2, 9, 4, 8],\n [3, 6, 5, 1]]\nTensorFlow uses row-major (C-style) format to represent the order of dimensions, which is why the shape in TensorFlow is [3,4] rather than [4,3]. In other words, in a two-dimensional TensorFlow Tensor, the shape is [number of rows, number of columns].\n\nA static shape is a tensor shape that is known at compile time.\n\nA dynamic shape is unknown at compile time and is therefore dependent on runtime data. This tensor might be represented with a placeholder dimension in TensorFlow, as in [3, ?].",
    "shard": "#TensorFlow#GoogleCloud\nA logical division of the training set or the model. Typically, some process creates shards by dividing the examples or parameters into (usually) equal-sized chunks. Each shard is then assigned to a different machine.\n\nSharding a model is called model parallelism; sharding data is called data parallelism.",
    "shrinkage": "#df\nA hyperparameter in gradient boosting that controls overfitting. Shrinkage in gradient boosting is analogous to learning rate in gradient descent. Shrinkage is a decimal value between 0.0 and 1.0. A lower shrinkage value reduces overfitting more than a larger shrinkage value.",
    "sigmoid function": "#fundamentals\nA mathematical function that \"squishes\" an input value into a constrained range, typically 0 to 1 or -1 to +1. That is, you can pass any number (two, a million, negative billion, whatever) to a sigmoid and the output will still be in the constrained range. A plot of the sigmoid activation function looks as follows:\n\nA two-dimensional curved plot with x values spanning the domain\n          -infinity to +positive, while y values span the range almost 0 to\n          almost 1. When x is 0, y is 0.5. The slope of the curve is always\n          positive, with the highest slope at 0,0.5 and gradually decreasing\n          slopes as the absolute value of x increases.\n\nThe sigmoid function has several uses in machine learning, including:\n\nConverting the raw output of a logistic regression or multinomial regression model to a probability.\nActing as an activation function in some neural networks.\n Click the icon to see the math.",
    "similarity measure": "#clustering#Metric\nIn clustering algorithms, the metric used to determine how alike (how similar) any two examples are.",
    "single program / multiple data (SPMD)": "A parallelism technique where the same computation is run on different input data in parallel on different devices. The goal of SPMD is to obtain results more quickly. It is the most common style of parallel programming.",
    "size invariance": "#image\nIn an image classification problem, an algorithm's ability to successfully classify images even when the size of the image changes. For example, the algorithm can still identify a cat whether it consumes 2M pixels or 200K pixels. Note that even the best image classification algorithms still have practical limits on size invariance. For example, an algorithm (or human) is unlikely to correctly classify a cat image consuming only 20 pixels.\n\nSee also translational invariance and rotational invariance.\n\nSee the Clustering course for more information.",
    "sketching": "#clustering\nIn unsupervised machine learning, a category of algorithms that perform a preliminary similarity analysis on examples. Sketching algorithms use a locality-sensitive hash function to identify points that are likely to be similar, and then group them into buckets.\n\nSketching decreases the computation required for similarity calculations on large datasets. Instead of calculating similarity for every single pair of examples in the dataset, we calculate similarity only for each pair of points within each bucket.",
    "skip-gram": "#language\nAn n-gram which may omit (or \"skip\") words from the original context, meaning the N words might not have been originally adjacent. More precisely, a \"k-skip-n-gram\" is an n-gram for which up to k words may have been skipped.\n\nFor example, \"the quick brown fox\" has the following possible 2-grams:\n\n\"the quick\"\n\"quick brown\"\n\"brown fox\"\nA \"1-skip-2-gram\" is a pair of words that have at most 1 word between them. Therefore, \"the quick brown fox\" has the following 1-skip 2-grams:\n\n\"the brown\"\n\"quick fox\"\nIn addition, all the 2-grams are also 1-skip-2-grams, since fewer than one word may be skipped.\n\nSkip-grams are useful for understanding more of a word's surrounding context. In the example, \"fox\" was directly associated with \"quick\" in the set of 1-skip-2-grams, but not in the set of 2-grams.\n\nSkip-grams help train word embedding models.",
    "softmax": "#fundamentals\nA function that determines probabilities for each possible class in a multi-class classification model. The probabilities add up to exactly 1.0. For example, the following table shows how softmax distributes various probabilities:\n\nImage is a...\tProbability\ndog\t.85\ncat\t.13\nhorse\t.02\nSoftmax is also called full softmax.\n\nContrast with candidate sampling.\n\n Click the icon to see the math.\nSee Neural networks: Multi-class classification in Machine Learning Crash Course for more information.",
    "soft prompt tuning": "#language#generativeAI\nA technique for tuning a large language model for a particular task, without resource intensive fine-tuning. Instead of retraining all the weights in the model, soft prompt tuning automatically adjusts a prompt to achieve the same goal.\n\nGiven a textual prompt, soft prompt tuning typically appends additional token embeddings to the prompt and uses backpropagation to optimize the input.\n\nA \"hard\" prompt contains actual tokens instead of token embeddings.",
    "sparse feature": "#language#fundamentals\nA feature whose values are predominately zero or empty. For example, a feature containing a single 1 value and a million 0 values is sparse. In contrast, a dense feature has values that are predominantly not zero or empty.\n\nIn machine learning, a surprising number of features are sparse features. Categorical features are usually sparse features. For example, of the 300 possible tree species in a forest, a single example might identify just a maple tree. Or, of the millions of possible videos in a video library, a single example might identify just \"Casablanca.\"\n\nIn a model, you typically represent sparse features with one-hot encoding. If the one-hot encoding is big, you might put an embedding layer on top of the one-hot encoding for greater efficiency.",
    "sparse representation": "#language#fundamentals\nStoring only the position(s) of nonzero elements in a sparse feature.\n\nFor example, suppose a categorical feature named species identifies the 36 tree species in a particular forest. Further assume that each example identifies only a single species.\n\nYou could use a one-hot vector to represent the tree species in each example. A one-hot vector would contain a single 1 (to represent the particular tree species in that example) and 35 0s (to represent the 35 tree species not in that example). So, the one-hot representation of maple might look something like the following:\n\nA vector in which positions 0 through 23 hold the value 0, position\n          24 holds the value 1, and positions 25 through 35 hold the value 0.\n\nAlternatively, sparse representation would simply identify the position of the particular species. If maple is at position 24, then the sparse representation of maple would simply be:\n\n24\nNotice that the sparse representation is much more compact than the one-hot representation.\n\nNote: You shouldn't pass a sparse representation as a direct feature input to a model. Instead, you should convert the sparse representation into a one-hot representation before training on it.\n Click the icon for a slightly more complex example.\n Click the icon if you are confused.\nSee Working with categorical data in Machine Learning Crash Course for more information.",
    "sparse vector": "#fundamentals\nA vector whose values are mostly zeroes. See also sparse feature and sparsity.",
    "sparsity": "#Metric\nThe number of elements set to zero (or null) in a vector or matrix divided by the total number of entries in that vector or matrix. For example, consider a 100-element matrix in which 98 cells contain zero. The calculation of sparsity is as follows:\n\nFeature sparsity refers to the sparsity of a feature vector; model sparsity refers to the sparsity of the model weights.",
    "spatial pooling": "#image\nSee pooling.",
    "split": "#df\nIn a decision tree, another name for a condition.",
    "splitter": "#df\nWhile training a decision tree, the routine (and algorithm) responsible for finding the best condition at each node.",
    "SPMD": "Abbreviation for single program / multiple data.",
    "squared hinge loss": "#Metric\nThe square of the hinge loss. Squared hinge loss penalizes outliers more harshly than regular hinge loss.",
    "squared loss": "#fundamentals#Metric\nSynonym for L2 loss.",
    "staged training": "#language\nA tactic of training a model in a sequence of discrete stages. The goal can be either to speed up the training process, or to achieve better model quality.\n\nAn illustration of the progressive stacking approach is shown below:\n\nStage 1 contains 3 hidden layers, stage 2 contains 6 hidden layers, and stage 3 contains 12 hidden layers.\nStage 2 begins training with the weights learned in the 3 hidden layers of Stage 1. Stage 3 begins training with the weights learned in the 6 hidden layers of Stage 2.\nThree stages, which are labeled Stage 1, Stage 2, and Stage 3.\n          Each stage contains a different number of layers: Stage 1 contains\n          3 layers, Stage 2 contains 6 layers, and Stage 3 contains 12 layers.\n          The 3 layers from Stage 1 become the first 3 layers of Stage 2.\n          Similarly, the 6 layers from Stage 2 become the first 6 layers of\n          Stage 3.\n\nSee also pipelining.",
    "state": "#rl\nIn reinforcement learning, the parameter values that describe the current configuration of the environment, which the agent uses to choose an action.",
    "state-action value function": "#rl\nSynonym for Q-function.",
    "static": "#fundamentals\nSomething done once rather than continuously. The terms static and offline are synonyms. The following are common uses of static and offline in machine learning:\n\nstatic model (or offline model) is a model trained once and then used for a while.\nstatic training (or offline training) is the process of training a static model.\nstatic inference (or offline inference) is a process in which a model generates a batch of predictions at a time.\nContrast with dynamic.",
    "static inference": "#fundamentals\nSynonym for offline inference.",
    "stationarity": "#fundamentals\nA feature whose values don't change across one or more dimensions, usually time. For example, a feature whose values look about the same in 2021 and 2023 exhibits stationarity.\n\nIn the real world, very few features exhibit stationarity. Even features synonymous with stability (like sea level) change over time.\n\nContrast with nonstationarity.",
    "step": "A forward pass and backward pass of one batch.\n\nSee backpropagation for more information on the forward pass and backward pass.",
    "step size": "Synonym for learning rate.",
    "stochastic gradient descent (SGD)": "#fundamentals\nA gradient descent algorithm in which the batch size is one. In other words, SGD trains on a single example chosen uniformly at random from a training set.\n\nSee Linear regression: Hyperparameters in Machine Learning Crash Course for more information.",
    "stride": "#image\nIn a convolutional operation or pooling, the delta in each dimension of the next series of input slices. For example, the following animation demonstrates a (1,1) stride during a convolutional operation. Therefore, the next input slice starts one position to the right of the previous input slice. When the operation reaches the right edge, the next slice is all the way over to the left but one position down.\n\nAn input 5x5 matrix and a 3x3 convolutional filter. Because the\n     stride is (1,1), a convolutional filter will be applied 9 times. The first\n     convolutional slice evaluates the top-left 3x3 submatrix of the input\n     matrix. The second slice evaluates the top-middle 3x3\n     submatrix. The third convolutional slice evaluates the top-right 3x3\n     submatrix. The fourth slice evaluates the middle-left 3x3 submatrix.\n     The fifth slice evaluates the middle 3x3 submatrix. The sixth slice\n     evaluates the middle-right 3x3 submatrix. The seventh slice evaluates\n     the bottom-left 3x3 submatrix. The eighth slice evaluates the\n     bottom-middle 3x3 submatrix. The ninth slice evaluates the bottom-right 3x3\n     submatrix.\n\nThe preceding example demonstrates a two-dimensional stride. If the input matrix is three-dimensional, the stride would also be three-dimensional.",
    "structural risk minimization (SRM)": "An algorithm that balances two goals:\n\nThe need to build the most predictive model (for example, lowest loss).\nThe need to keep the model as simple as possible (for example, strong regularization).\nFor example, a function that minimizes loss+regularization on the training set is a structural risk minimization algorithm.\n\nContrast with empirical risk minimization.",
    "subsampling": "#image\nSee pooling.",
    "subword token": "#language\nIn language models, a token that is a substring of a word, which may be the entire word.\n\nFor example, a word like \"itemize\" might be broken up into the pieces \"item\" (a root word) and \"ize\" (a suffix), each of which is represented by its own token. Splitting uncommon words into such pieces, called subwords, allows language models to operate on the word's more common constituent parts, such as prefixes and suffixes.\n\nConversely, common words like \"going\" might not be broken up and might be represented by a single token.",
    "summary": "#TensorFlow\nIn TensorFlow, a value or set of values calculated at a particular step, usually used for tracking model metrics during training.",
    "supervised machine learning": "#fundamentals\nTraining a model from features and their corresponding labels. Supervised machine learning is analogous to learning a subject by studying a set of questions and their corresponding answers. After mastering the mapping between questions and answers, a student can then provide answers to new (never-before-seen) questions on the same topic.\n\nCompare with unsupervised machine learning.\n\nSee Supervised Learning in the Introduction to ML course for more information.",
    "synthetic feature": "#fundamentals\nA feature not present among the input features, but assembled from one or more of them. Methods for creating synthetic features include the following:\n\nBucketing a continuous feature into range bins.\nCreating a feature cross.\nMultiplying (or dividing) one feature value by other feature value(s) or by itself. For example, if a and b are input features, then the following are examples of synthetic features:\nab\na2\nApplying a transcendental function to a feature value. For example, if c is an input feature, then the following are examples of synthetic features:\nsin(c)\nln(c)\nFeatures created by normalizing or scaling alone are not considered synthetic features.\n\n\nT",
    "T5": "#language\nA text-to-text transfer learning model introduced by Google AI in 2020. T5 is an encoder-decoder model, based on the Transformer architecture, trained on an extremely large dataset. It is effective at a variety of natural language processing tasks, such as generating text, translating languages, and answering questions in a conversational manner.\n\nT5 gets its name from the five T's in \"Text-to-Text Transfer Transformer.\"",
    "T5X": "#language\nAn open-source, machine learning framework designed to build and train large-scale natural language processing (NLP) models. T5 is implemented on the T5X codebase (which is built on JAX and Flax).",
    "tabular Q-learning": "#rl\nIn reinforcement learning, implementing Q-learning by using a table to store the Q-functions for every combination of state and action.",
    "target": "Synonym for label.",
    "target network": "#rl\nIn Deep Q-learning, a neural network that is a stable approximation of the main neural network, where the main neural network implements either a Q-function or a policy. Then, you can train the main network on the Q-values predicted by the target network. Therefore, you prevent the feedback loop that occurs when the main network trains on Q-values predicted by itself. By avoiding this feedback, training stability increases.",
    "task": "A problem that can be solved using machine learning techniques, such as:",
    "classification": "regression\nclustering\nanomaly detection",
    "temperature": "#language#image#generativeAI\nA hyperparameter that controls the degree of randomness of a model's output. Higher temperatures result in more random output, while lower temperatures result in less random output.\n\nChoosing the best temperature depends on the specific application and the preferred properties of the model's output. For example, you would probably raise the temperature when creating an application that generates creative output. Conversely, you would probably lower the temperature when building a model that classifies images or text in order to improve the model's accuracy and consistency.\n\nTemperature is often used with softmax.",
    "temporal data": "Data recorded at different points in time. For example, winter coat sales recorded for each day of the year would be temporal data.",
    "Tensor": "#TensorFlow\nThe primary data structure in TensorFlow programs. Tensors are N-dimensional (where N could be very large) data structures, most commonly scalars, vectors, or matrixes. The elements of a Tensor can hold integer, floating-point, or string values.",
    "TensorBoard": "#TensorFlow\nThe dashboard that displays the summaries saved during the execution of one or more TensorFlow programs.",
    "TensorFlow": "#TensorFlow\nA large-scale, distributed, machine learning platform. The term also refers to the base API layer in the TensorFlow stack, which supports general computation on dataflow graphs.\n\nAlthough TensorFlow is primarily used for machine learning, you may also use TensorFlow for non-ML tasks that require numerical computation using dataflow graphs.",
    "TensorFlow Playground": "#TensorFlow\nA program that visualizes how different hyperparameters influence model (primarily neural network) training. Go to http://playground.tensorflow.org to experiment with TensorFlow Playground.",
    "TensorFlow Serving": "#TensorFlow\nA platform to deploy trained models in production.",
    "Tensor Processing Unit (TPU)": "#TensorFlow#GoogleCloud\nAn application-specific integrated circuit (ASIC) that optimizes the performance of machine learning workloads. These ASICs are deployed as multiple TPU chips on a TPU device.",
    "Tensor rank": "#TensorFlow\nSee rank (Tensor).",
    "Tensor shape": "#TensorFlow\nThe number of elements a Tensor contains in various dimensions. For example, a [5, 10] Tensor has a shape of 5 in one dimension and 10 in another.",
    "Tensor size": "#TensorFlow\nThe total number of scalars a Tensor contains. For example, a [5, 10] Tensor has a size of 50.",
    "TensorStore": "A library for efficiently reading and writing large multi-dimensional arrays.",
    "termination condition": "#rl\nIn reinforcement learning, the conditions that determine when an episode ends, such as when the agent reaches a certain state or exceeds a threshold number of state transitions. For example, in tic-tac-toe (also known as noughts and crosses), an episode terminates either when a player marks three consecutive spaces or when all spaces are marked.",
    "test": "#df\nIn a decision tree, another name for a condition.",
    "test loss": "#fundamentals#Metric\nA metric representing a model's loss against the test set. When building a model, you typically try to minimize test loss. That's because a low test loss is a stronger quality signal than a low training loss or low validation loss.\n\nA large gap between test loss and training loss or validation loss sometimes suggests that you need to increase the regularization rate.",
    "test set": "A subset of the dataset reserved for testing a trained model.\n\nTraditionally, you divide examples in the dataset into the following three distinct subsets:\n\na training set\na validation set\na test set\nEach example in a dataset should belong to only one of the preceding subsets. For instance, a single example shouldn't belong to both the training set and the test set.\n\nThe training set and validation set are both closely tied to training a model. Because the test set is only indirectly associated with training, test loss is a less biased, higher quality metric than training loss or validation loss.\n\nSee Datasets: Dividing the original dataset in Machine Learning Crash Course for more information.",
    "text span": "#language\nThe array index span associated with a specific subsection of a text string. For example, the word good in the Python string s=\"Be good now\" occupies the text span from 3 to 6.",
    "tf.Example": "#TensorFlow\nA standard protocol buffer for describing input data for machine learning model training or inference.",
    "tf.keras": "#TensorFlow\nAn implementation of Keras integrated into TensorFlow.",
    "threshold (for decision trees)": "#df\nIn an axis-aligned condition, the value that a feature is being compared against. For example, 75 is the threshold value in the following condition:\n\ngrade >= 75\nThis form of the term threshold is different than classification threshold.\nSee Exact splitter for binary classification with numerical features in the Decision Forests course for more information.",
    "time series analysis": "#clustering\nA subfield of machine learning and statistics that analyzes temporal data. Many types of machine learning problems require time series analysis, including classification, clustering, forecasting, and anomaly detection. For example, you could use time series analysis to forecast the future sales of winter coats by month based on historical sales data.",
    "timestep": "#seq\nOne \"unrolled\" cell within a recurrent neural network. For example, the following figure shows three timesteps (labeled with the subscripts t-1, t, and t+1):\n\nThree timesteps in a recurrent neural network. The output of the\n          first timestep becomes input to the second timestep. The output\n          of the second timestep becomes input to the third timestep.",
    "token": "#language\nIn a language model, the atomic unit that the model is training on and making predictions on. A token is typically one of the following:\n\na word\u2014for example, the phrase \"dogs like cats\" consists of three word tokens: \"dogs\", \"like\", and \"cats\".\na character\u2014for example, the phrase \"bike fish\" consists of nine character tokens. (Note that the blank space counts as one of the tokens.)\nsubwords\u2014in which a single word can be a single token or multiple tokens. A subword consists of a root word, a prefix, or a suffix. For example, a language model that uses subwords as tokens might view the word \"dogs\" as two tokens (the root word \"dog\" and the plural suffix \"s\"). That same language model might view the single word \"taller\" as two subwords (the root word \"tall\" and the suffix \"er\").\nIn domains outside of language models, tokens can represent other kinds of atomic units. For example, in computer vision, a token might be a subset of an image.\n\nSee Large language models in Machine Learning Crash Course for more information.",
    "top-k accuracy": "#language#Metric\nThe percentage of times that a \"target label\" appears within the first k positions of generated lists. The lists could be personalized recommendations or a list of items ordered by softmax.\n\nTop-k accuracy is also known as accuracy at k.\n\nNote: The target label could be any class (not necessarily the ground truth class), so top-k accuracy is not always equivalent to traditional accuracy.\n Click the icon for an example.",
    "tower": "A component of a deep neural network that is itself a deep neural network. In some cases, each tower reads from an independent data source, and those towers stay independent until their output is combined in a final layer. In other cases, (for example, in the encoder and decoder tower of many Transformers), towers have cross-connections to each other.",
    "toxicity": "#language#Metric\nThe degree to which content is abusive, threatening, or offensive. Many machine learning models can identify and measure toxicity. Most of these models identify toxicity along multiple parameters, such as the level of abusive language and the level of threatening language.",
    "TPU": "#TensorFlow#GoogleCloud\nAbbreviation for Tensor Processing Unit.",
    "TPU chip": "#TensorFlow#GoogleCloud\nA programmable linear algebra accelerator with on-chip high bandwidth memory that is optimized for machine learning workloads. Multiple TPU chips are deployed on a TPU device.",
    "TPU device": "#TensorFlow#GoogleCloud\nA printed circuit board (PCB) with multiple TPU chips, high bandwidth network interfaces, and system cooling hardware.",
    "TPU node": "#TensorFlow#GoogleCloud\nA TPU resource on Google Cloud with a specific TPU type. The TPU node connects to your VPC Network from a peer VPC network. TPU nodes are a resource defined in the Cloud TPU API.",
    "TPU Pod": "#TensorFlow#GoogleCloud\nA specific configuration of TPU devices in a Google data center. All of the devices in a TPU Pod are connected to one another over a dedicated high-speed network. A TPU Pod is the largest configuration of TPU devices available for a specific TPU version.",
    "TPU resource": "#TensorFlow#GoogleCloud\nA TPU entity on Google Cloud that you create, manage, or consume. For example, TPU nodes and TPU types are TPU resources.",
    "TPU slice": "#TensorFlow#GoogleCloud\nA TPU slice is a fractional portion of the TPU devices in a TPU Pod. All of the devices in a TPU slice are connected to one another over a dedicated high-speed network.",
    "TPU type": "#TensorFlow#GoogleCloud\nA configuration of one or more TPU devices with a specific TPU hardware version. You select a TPU type when you create a TPU node on Google Cloud. For example, a v2-8 TPU type is a single TPU v2 device with 8 cores. A v3-2048 TPU type has 256 networked TPU v3 devices and a total of 2048 cores. TPU types are a resource defined in the Cloud TPU API.",
    "TPU worker": "#TensorFlow#GoogleCloud\nA process that runs on a host machine and executes machine learning programs on TPU devices.",
    "training": "#fundamentals\nThe process of determining the ideal parameters (weights and biases) comprising a model. During training, a system reads in examples and gradually adjusts parameters. Training uses each example anywhere from a few times to billions of times.\n\nSee Supervised Learning in the Introduction to ML course for more information.",
    "training loss": "#fundamentals#Metric\nA metric representing a model's loss during a particular training iteration. For example, suppose the loss function is Mean Squared Error. Perhaps the training loss (the Mean Squared Error) for the 10th iteration is 2.2, and the training loss for the 100th iteration is 1.9.\n\nA loss curve plots training loss versus the number of iterations. A loss curve provides the following hints about training:\n\nA downward slope implies that the model is improving.\nAn upward slope implies that the model is getting worse.\nA flat slope implies that the model has reached convergence.\nFor example, the following somewhat idealized loss curve shows:\n\nA steep downward slope during the initial iterations, which implies rapid model improvement.\nA gradually flattening (but still downward) slope until close to the end of training, which implies continued model improvement at a somewhat slower pace then during the initial iterations.\nA flat slope towards the end of training, which suggests convergence.\nThe plot of training loss versus iterations. This loss curve starts\n     with a steep downward slope. The slope gradually flattens until the\n     slope becomes zero.\n\nAlthough training loss is important, see also generalization.",
    "training-serving skew": "#fundamentals\nThe difference between a model's performance during training and that same model's performance during serving.",
    "training set": "#fundamentals\nThe subset of the dataset used to train a model.\n\nTraditionally, examples in the dataset are divided into the following three distinct subsets:\n\na training set\na validation set\na test set\nIdeally, each example in the dataset should belong to only one of the preceding subsets. For example, a single example shouldn't belong to both the training set and the validation set.\n\nSee Datasets: Dividing the original dataset in Machine Learning Crash Course for more information.",
    "trajectory": "#rl\nIn reinforcement learning, a sequence of tuples that represent a sequence of state transitions of the agent, where each tuple corresponds to the state, action, reward, and next state for a given state transition.",
    "transfer learning": "Transferring information from one machine learning task to another. For example, in multi-task learning, a single model solves multiple tasks, such as a deep model that has different output nodes for different tasks. Transfer learning might involve transferring knowledge from the solution of a simpler task to a more complex one, or involve transferring knowledge from a task where there is more data to one where there is less data.\n\nMost machine learning systems solve a single task. Transfer learning is a baby step towards artificial intelligence in which a single program can solve multiple tasks.",
    "Transformer": "#language\nA neural network architecture developed at Google that relies on self-attention mechanisms to transform a sequence of input embeddings into a sequence of output embeddings without relying on convolutions or recurrent neural networks. A Transformer can be viewed as a stack of self-attention layers.\n\nA Transformer can include any of the following:\n\nan encoder\na decoder\nboth an encoder and decoder\nAn encoder transforms a sequence of embeddings into a new sequence of the same length. An encoder includes N identical layers, each of which contains two sub-layers. These two sub-layers are applied at each position of the input embedding sequence, transforming each element of the sequence into a new embedding. The first encoder sub-layer aggregates information from across the input sequence. The second encoder sub-layer transforms the aggregated information into an output embedding.\n\nA decoder transforms a sequence of input embeddings into a sequence of output embeddings, possibly with a different length. A decoder also includes N identical layers with three sub-layers, two of which are similar to the encoder sub-layers. The third decoder sub-layer takes the output of the encoder and applies the self-attention mechanism to gather information from it.\n\nThe blog post Transformer: A Novel Neural Network Architecture for Language Understanding provides a good introduction to Transformers.\n\nSee LLMs: What's a large language model? in Machine Learning Crash Course for more information.",
    "translational invariance": "#image\nIn an image classification problem, an algorithm's ability to successfully classify images even when the position of objects within the image changes. For example, the algorithm can still identify a dog, whether it is in the center of the frame or at the left end of the frame.\n\nSee also size invariance and rotational invariance.",
    "trigram": "#seq#language\nAn N-gram in which N=3.",
    "true negative (TN)": "#fundamentals#Metric\nAn example in which the model correctly predicts the negative class. For example, the model infers that a particular email message is not spam, and that email message really is not spam.",
    "true positive (TP)": "#fundamentals#Metric\nAn example in which the model correctly predicts the positive class. For example, the model infers that a particular email message is spam, and that email message really is spam.",
    "true positive rate (TPR)": "#fundamentals#Metric\nSynonym for recall. That is:\n\nTrue positive rate is the y-axis in an ROC curve.\n\n\nU",
    "unawareness (to a sensitive attribute)": "#fairness\nA situation in which sensitive attributes are present, but not included in the training data. Because sensitive attributes are often correlated with other attributes of one's data, a model trained with unawareness about a sensitive attribute could still have disparate impact with respect to that attribute, or violate other fairness constraints.",
    "underfitting": "#fundamentals\nProducing a model with poor predictive ability because the model hasn't fully captured the complexity of the training data. Many problems can cause underfitting, including:\n\nTraining on the wrong set of features.\nTraining for too few epochs or at too low a learning rate.\nTraining with too high a regularization rate.\nProviding too few hidden layers in a deep neural network.\nSee Overfitting in Machine Learning Crash Course for more information.",
    "undersampling": "Removing examples from the majority class in a class-imbalanced dataset in order to create a more balanced training set.\n\nFor example, consider a dataset in which the ratio of the majority class to the minority class is 20:1. To overcome this class imbalance, you could create a training set consisting of all of the minority class examples but only a tenth of the majority class examples, which would create a training-set class ratio of 2:1. Thanks to undersampling, this more balanced training set might produce a better model. Alternatively, this more balanced training set might contain insufficient examples to train an effective model.\n\nContrast with oversampling.",
    "unidirectional": "#language\nA system that only evaluates the text that precedes a target section of text. In contrast, a bidirectional system evaluates both the text that precedes and follows a target section of text. See bidirectional for more details.",
    "unidirectional language model": "#language\nA language model that bases its probabilities only on the tokens appearing before, not after, the target token(s). Contrast with bidirectional language model.",
    "unlabeled example": "#fundamentals\nAn example that contains features but no label. For example, the following table shows three unlabeled examples from a house valuation model, each with three features but no house value:\n\nNumber of bedrooms\tNumber of bathrooms\tHouse age\n3\t2\t15\n2\t1\t72\n4\t2\t34\nIn supervised machine learning, models train on labeled examples and make predictions on unlabeled examples.\n\nIn semi-supervised and unsupervised learning, unlabeled examples are used during training.\n\nContrast unlabeled example with labeled example.",
    "unsupervised machine learning": "#clustering#fundamentals\nTraining a model to find patterns in a dataset, typically an unlabeled dataset.\n\nThe most common use of unsupervised machine learning is to cluster data into groups of similar examples. For example, an unsupervised machine learning algorithm can cluster songs based on various properties of the music. The resulting clusters can become an input to other machine learning algorithms (for example, to a music recommendation service). Clustering can help when useful labels are scarce or absent. For example, in domains such as anti-abuse and fraud, clusters can help humans better understand the data.\n\nContrast with supervised machine learning.\n\n Click the icon for additional notes.\nSee What is Machine Learning? in the Introduction to ML course for more information.",
    "uplift modeling": "A modeling technique, commonly used in marketing, that models the \"causal effect\" (also known as the \"incremental impact\") of a \"treatment\" on an \"individual.\" Here are two examples:\n\nDoctors might use uplift modeling to predict the mortality decrease (causal effect) of a medical procedure (treatment) depending on the age and medical history of a patient (individual).\nMarketers might use uplift modeling to predict the increase in probability of a purchase (causal effect) due to an advertisement (treatment) on a person (individual).\nUplift modeling differs from classification or regression in that some labels (for example, half of the labels in binary treatments) are always missing in uplift modeling. For example, a patient can either receive or not receive a treatment; therefore, we can only observe whether the patient is going to heal or not heal in only one of these two situations (but never both). The main advantage of an uplift model is that it can generate predictions for the unobserved situation (the counterfactual) and use it to compute the causal effect.",
    "upweighting": "Applying a weight to the downsampled class equal to the factor by which you downsampled.",
    "user matrix": "#recsystems\nIn recommendation systems, an embedding vector generated by matrix factorization that holds latent signals about user preferences. Each row of the user matrix holds information about the relative strength of various latent signals for a single user. For example, consider a movie recommendation system. In this system, the latent signals in the user matrix might represent each user's interest in particular genres, or might be harder-to-interpret signals that involve complex interactions across multiple factors.\n\nThe user matrix has a column for each latent feature and a row for each user. That is, the user matrix has the same number of rows as the target matrix that is being factorized. For example, given a movie recommendation system for 1,000,000 users, the user matrix will have 1,000,000 rows.\n\n\nV",
    "validation": "#fundamentals\nThe initial evaluation of a model's quality. Validation checks the quality of a model's predictions against the validation set.\n\nBecause the validation set differs from the training set, validation helps guard against overfitting.\n\nYou might think of evaluating the model against the validation set as the first round of testing and evaluating the model against the test set as the second round of testing.",
    "validation loss": "#fundamentals#Metric\nA metric representing a model's loss on the validation set during a particular iteration of training.\n\nSee also generalization curve.",
    "validation set": "#fundamentals\nThe subset of the dataset that performs initial evaluation against a trained model. Typically, you evaluate the trained model against the validation set several times before evaluating the model against the test set.\n\nTraditionally, you divide the examples in the dataset into the following three distinct subsets:\n\na training set\na validation set\na test set\nIdeally, each example in the dataset should belong to only one of the preceding subsets. For example, a single example shouldn't belong to both the training set and the validation set.\n\nSee Datasets: Dividing the original dataset in Machine Learning Crash Course for more information.",
    "value imputation": "The process of replacing a missing value with an acceptable substitute. When a value is missing, you can either discard the entire example or you can use value imputation to salvage the example.\n\nFor example, consider a dataset containing a temperature feature that is supposed to be recorded every hour. However, the temperature reading was unavailable for a particular hour. Here is a section of the dataset:\n\nTimestamp\tTemperature\n1680561000\t10\n1680564600\t12\n1680568200\tmissing\n1680571800\t20\n1680575400\t21\n1680579000\t21\nA system could either delete the missing example or impute the missing temperature as 12, 16, 18, or 20, depending on the imputation algorithm.",
    "vanishing gradient problem": "#seq\nThe tendency for the gradients of early hidden layers of some deep neural networks to become surprisingly flat (low). Increasingly lower gradients result in increasingly smaller changes to the weights on nodes in a deep neural network, leading to little or no learning. Models suffering from the vanishing gradient problem become difficult or impossible to train. Long Short-Term Memory cells address this issue.\n\nCompare to exploding gradient problem.",
    "variable importances": "#df#Metric\nA set of scores that indicates the relative importance of each feature to the model.\n\nFor example, consider a decision tree that estimates house prices. Suppose this decision tree uses three features: size, age, and style. If a set of variable importances for the three features are calculated to be {size=5.8, age=2.5, style=4.7}, then size is more important to the decision tree than age or style.\n\nDifferent variable importance metrics exist, which can inform ML experts about different aspects of models.",
    "variational autoencoder (VAE)": "#language\nA type of autoencoder that leverages the discrepancy between inputs and outputs to generate modified versions of the inputs. Variational autoencoders are useful for generative AI.\n\nVAEs are based on variational inference: a technique for estimating the parameters of a probability model.",
    "vector": "Very overloaded term whose meaning varies across different mathematical and scientific fields. Within machine learning, a vector has two properties:\n\nData type: Vectors in machine learning usually hold floating-point numbers.\nNumber of elements: This is the vector's length or its dimension.\nFor example, consider a feature vector that holds eight floating-point numbers. This feature vector has a length or dimension of eight. Note that machine learning vectors often have a huge number of dimensions.\n\nYou can represent many different kinds of information as a vector. For example:\n\nAny position on the surface of Earth can be represented as a 2-dimensional vector, where one dimension is the latitude and the other is the longitude.\nThe current prices of each of 500 stocks can be represented as a 500-dimensional vector.\nA probability distribution over a finite number of classes can be represented as a vector. For example, a multiclass classification system that predicts one of three output colors (red, green, or yellow) could output the vector (0.3, 0.2, 0.5) to mean P[red]=0.3, P[green]=0.2, P[yellow]=0.5.\nVectors can be concatenated; therefore, a variety of different media can be represented as a single vector. Some models operate directly on the concatenation of many one-hot encodings.\n\nSpecialized processors such as TPUs are optimized to perform mathematical operations on vectors.\n\nA vector is a tensor of rank 1.\n\n\nW",
    "Wasserstein loss": "#Metric\nOne of the loss functions commonly used in generative adversarial networks, based on the earth mover's distance between the distribution of generated data and real data.",
    "weight": "#fundamentals\nA value that a model multiplies by another value. Training is the process of determining a model's ideal weights; inference is the process of using those learned weights to make predictions.\n\n Click the icon to see an example of weights in a linear model.\nSee Linear regression in Machine Learning Crash Course for more information.",
    "Weighted Alternating Least Squares (WALS)": "#recsystems\nAn algorithm for minimizing the objective function during matrix factorization in recommendation systems, which allows a downweighting of the missing examples. WALS minimizes the weighted squared error between the original matrix and the reconstruction by alternating between fixing the row factorization and column factorization. Each of these optimizations can be solved by least squares convex optimization. For details, see the Recommendation Systems course.",
    "weighted sum": "#fundamentals\nThe sum of all the relevant input values multiplied by their corresponding weights. For example, suppose the relevant inputs consist of the following:\n\ninput value\tinput weight\n2\t-1.3\n-1\t0.6\n3\t0.4\nThe weighted sum is therefore:\n\nweighted sum = (2)(-1.3) + (-1)(0.6) + (3)(0.4) = -2.0\nA weighted sum is the input argument to an activation function.",
    "wide model": "A linear model that typically has many sparse input features. We refer to it as \"wide\" since such a model is a special type of neural network with a large number of inputs that connect directly to the output node. Wide models are often easier to debug and inspect than deep models. Although wide models cannot express nonlinearities through hidden layers, wide models can use transformations such as feature crossing and bucketization to model nonlinearities in different ways.\n\nContrast with deep model.",
    "width": "The number of neurons in a particular layer of a neural network.",
    "wisdom of the crowd": "#df\nThe idea that averaging the opinions or estimates of a large group of people (\"the crowd\") often produces surprisingly good results. For example, consider a game in which people guess the number of jelly beans packed into a large jar. Although most individual guesses will be inaccurate, the average of all the guesses has been empirically shown to be surprisingly close to the actual number of jelly beans in the jar.\n\nEnsembles are a software analog of wisdom of the crowd. Even if individual models make wildly inaccurate predictions, averaging the predictions of many models often generates surprisingly good predictions. For example, although an individual decision tree might make poor predictions, a decision forest often makes very good predictions.",
    "word embedding": "#language\nRepresenting each word in a word set within an embedding vector; that is, representing each word as a vector of floating-point values between 0.0 and 1.0. Words with similar meanings have more-similar representations than words with different meanings. For example, carrots, celery, and cucumbers would all have relatively similar representations, which would be very different from the representations of airplane, sunglasses, and toothpaste.\n\n\nX",
    "XLA (Accelerated Linear Algebra)": "An open-source machine learning compiler for GPUs, CPUs, and ML accelerators.\n\nThe XLA compiler takes models from popular ML frameworks such as PyTorch, TensorFlow, and JAX, and optimizes them for high-performance execution across different hardware platforms including GPUs, CPUs, and ML accelerators.\n\n\nZ",
    "zero-shot learning": "A type of machine learning training where the model infers a prediction for a task that it was not specifically already trained on. In other words, the model is given zero task-specific training examples but asked to do inference for that task.",
    "zero-shot prompting": "#language#generativeAI\nA prompt that does not provide an example of how you want the large language model to respond. For example:\n\nParts of one prompt\tNotes\nWhat is the official currency of the specified country?\tThe question you want the LLM to answer.\nIndia:\tThe actual query.\nThe large language model might respond with any of the following:\n\nRupee\nINR\n\u20b9\nIndian rupee\nThe rupee\nThe Indian rupee\nAll of the answers are correct, though you might prefer a particular format.\n\nCompare and contrast zero-shot prompting with the following terms:\n\none-shot prompting\nfew-shot prompting",
    "Z-score normalization": "#fundamentals\nA scaling technique that replaces a raw feature value with a floating-point value representing the number of standard deviations from that feature's mean. For example, consider a feature whose mean is 800 and whose standard deviation is 100. The following table shows how Z-score normalization would map the raw value to its Z-score:\n\nRaw value\tZ-score\n800\t0\n950\t+1.5\n575\t-2.25\nThe machine learning model then trains on the Z-scores for that feature instead of on the raw values.\n\nSee Numerical data: Normalization in Machine Learning Crash Course for more information.\n\n }\n}"

 }
